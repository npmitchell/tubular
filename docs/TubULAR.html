<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="DEC is a Discrete Exterior Calculus toolbox for MATLAB." href="DEC.html" /><link rel="prev" title="Example for using TubULAR after making an ImSAnE experiment instance" href="example_usage_tubular_with_imsane.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.03.04"/>
        <title>TubULAR - TubULAR 2022 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=935aa2abcc5c1da4283d1dc201fb1f0add16d23a" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=25ceb02ed1c46dc30f2321ff83e92799f69dfdb9" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">TubULAR 2022 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">TubULAR 2022 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_gutSample.html">Example for using TubULAR: midgut data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular.html">Example for using TubULAR: synthetic data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_for_surface_visualization.html">Example for using TubULAR just for surface visualization</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_zebrafish_heart.html">Example for using TubULAR: zebrafish heart dynamics</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="faq_debugging.html">Common issues in TubULAR and suggestions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_imsane_with_tubular.html">Example for using TubULAR methods within ImSAnE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_with_imsane.html">Example for using TubULAR after making an ImSAnE experiment instance</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Principal contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children current-page"><a class="current reference internal" href="#">TubULAR</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#coordinate-systems">Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="#apdv-coordinate-system-and-centerline-specification">APDV coordinate system and Centerline specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="#properties">Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-@TubULAR">Full Contents:</a></li>
<li class="toctree-l1"><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="DEC.html">DEC is a Discrete Exterior Calculus toolbox for MATLAB.</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="example_DEC_diskMesh.html">Example for analyzing flow on a planar surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_DEC_sphericalMesh.html">Example for analyzing flow on a spherical surface</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container"><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="tubular">
<h1>TubULAR<a class="headerlink" href="#tubular" title="Permalink to this headline">#</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>Tube-like sUrface Lagrangian Analysis Resource (TubULAR) class</p>
</section>
<section id="coordinate-systems">
<h1>Coordinate Systems<a class="headerlink" href="#coordinate-systems" title="Permalink to this headline">#</a></h1>
<dl class="simple">
<dt><strong>uv</strong><span class="classifier">(conformal map onto unit square)</span></dt><dd><p>Conformally mapping the cylinderCutMesh onto the unit square
in the plane results in the instantaneous uv coordinate system.
Corners of the unit square are taken directly from the cutMesh,
so are liable to include some overall twist.</p>
</dd>
<dt><strong>sphi</strong><span class="classifier">(proper length x rectified azimuthal coordinate)</span></dt><dd><p>Cylinder-like coordinate system in which first coordinate is the
proper length along the surface and second is a rectified azimuthal
coordinate. Rectification means that the surface is rotated at
each longitudinal coordinate <code class="docutils literal notranslate"><span class="pre">u</span></code> so that the surface changes as
little as possible over time. Mathematically, <code class="docutils literal notranslate"><span class="pre">v</span></code> is taken to
<code class="docutils literal notranslate"><span class="pre">phi(u)</span></code>, where each <code class="docutils literal notranslate"><span class="pre">u</span></code> coordinate is offset by a “rotation”
about the surface along the <code class="docutils literal notranslate"><span class="pre">v</span></code> direction (the circumferential direction).
This rectification may be based on surface positions in R^3 (geometric) or
based on intensity motion in pullback space (material/Lagrangian)
inferred through phase-correlation of the tissue at each <code class="docutils literal notranslate"><span class="pre">u</span></code>
value (averaged across <code class="docutils literal notranslate"><span class="pre">v</span></code>).</p>
</dd>
<dt><strong>sphi_sm</strong><span class="classifier">(proper length x rectified azimuthal coordinate, smoothed in time)</span></dt><dd><p>Same as sphi, but coordiantes smoothed over time with a tripulse
filter.</p>
</dd>
<dt><strong>APDV</strong><span class="classifier">(rotated, translated, and scaled coordinate system, like lab frame)</span></dt><dd><p>Physical coordinates used to visualize dynamics. Aligned meshes are in this
3D coordinate system.</p>
</dd>
<dt><strong>xyz</strong><span class="classifier">(data coordinate system)</span></dt><dd><p>Pixel coordinates of the data itself. Raw meshes, cylinder meshes, cutMeshes
etc are in this 3D coordinate system.</p>
</dd>
</dl>
<p>PIV measurement can be automatically computed in pullback space to determine 3D motion. These measurements can be done in a coordinate system of your choice (uv, sphi, or sphi_sm).</p>
</section>
<section id="apdv-coordinate-system-and-centerline-specification">
<h1>APDV coordinate system and Centerline specification<a class="headerlink" href="#apdv-coordinate-system-and-centerline-specification" title="Permalink to this headline">#</a></h1>
<p>QuapSlap allows the user to designate the AP axis, a DV axis, and a
centerline for the segmented object.
The default APDV coordinate system is automatically determined from the
elongation axis of the surface and the data axes.</p>
<p>To customize, you can designate an APDV coordinate system that may be
biologically relevant by using iLastik training on the
timepoint t0 (which is an attribute of tubi, found as tubi.t0).
Train in iLastik on anterior (A), posterior (P), background (B), and dorsal (D) location
in different iLastik channels, making small blobs of high probability near
the anterior end (A), somewhere along the posterior end for (P) so that AP forms the AP axis, and
anywhere along dorsal for D. Then the centers of mass of
thresholded contiguous high probability are computed for each to
define the coordinate system. By default for this customized option, the ilastik results are
read as ch1=A, ch2=P, ch3=B, ch4=D, but you may specify anteriorChannel,
posteriorChannel, and dorsalChannel to specify the iLastik
training channel that is used for each.
Name the h5 file output from iLastik as
…_Probabilities_APDVcoords.h5
For example, dorsal for the gut was chosen at the fused site where
additional 48YGAL4-expressing muscle-like cells form a seam.
Posterior is at the rear of the yolk, where the endoderm closes, for
apical surface training. Anterior is at the junction of the midgut
with the foregut.
Separately, define the AP points for centerline extraction. For most gut
data, the posterior point is different in centerline than it is for AP
centerline specification, so we use a different ILP to train for A and P
for all timepoints of dynamic data.</p>
</section>
<section id="properties">
<h1>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">#</a></h1>
<dl>
<dt>xp<span class="classifier">ImSAnE experiment class instance or struct with fields</span></dt><dd><p>expMeta : struct with fields
fileMeta : struct with fields</p>
</dd>
<dt>dynamic<span class="classifier">bool</span></dt><dd><p>true if multiple timepoints, false if fixed</p>
</dd>
<dt>timeInterval<span class="classifier">numeric, default=1</span></dt><dd><p>increment in time between timepoints with
indices differing by 1. For example, if
timePoints are [0,1,2,4] and these are
[1,1,2] minutes apart, then timeInterval
is 1.</p>
</dd>
<dt>timeUnits<span class="classifier">str (default=’min’)</span></dt><dd><p>units of the timeInterval (ex ‘min’)</p>
</dd>
<dt>spaceUnits<span class="classifier">str (default = ‘$mu$m’)</span></dt><dd><p>units of the embedding space (ex ‘$mu$m’)</p>
</dd>
<dt>imSize<span class="classifier">2x1 int</span></dt><dd><p>size of pullback images to create (default is [a_ratio * 1000, 1000])</p>
</dd>
<dt>dir<span class="classifier">struct with fields for different saved data names</span></dt><dd><p>directories where QuapSlap data lives</p>
</dd>
<dt>fileName<span class="classifier">struct with fields for different saved data names</span></dt><dd><p>Full filenames (with the absolute path) for various data and results</p>
</dd>
<dt>fileBase<span class="classifier">struct with fields for different saved data names</span></dt><dd><p>Relative fileNames to be populated by timestamp (’…%06d…mat’)</p>
</dd>
<dt>fullFileBase<span class="classifier">struct with fields for different saved data names</span></dt><dd><p>full path of filenames (like fullfile(tubi.dir.X, tubi.fileBase.X))</p>
</dd>
<dt>ssfactor<span class="classifier">int</span></dt><dd><p>subsampling factor for probabilities</p>
</dd>
<dt>APDV<span class="classifier">struct with fields</span></dt><dd><dl class="simple">
<dt>‘resolution’, float</dt><dd><p>resolution of data in spaceUnits / pixel</p>
</dd>
<dt>‘rot’<span class="classifier">3x3 rotation matrix</span></dt><dd><p>rotation matrix to transform 3d pts from data frame into APDV frame accordint to v’ = (rot*v+trans)*resolution</p>
</dd>
<dt>‘trans’<span class="classifier">1x3 float array</span></dt><dd><p>translation vector to transform 3d pts from data frame into APDV frame according to v’ = (rot*v+trans)*resolution</p>
</dd>
</dl>
</dd>
<dt>flipy<span class="classifier">bool</span></dt><dd><p>whether data is mirror image of lab frame coordinates</p>
</dd>
<dt>nV<span class="classifier">int (default=100)</span></dt><dd><p>sampling number along circumferential axis</p>
</dd>
<dt>nU<span class="classifier">int (default=100)</span></dt><dd><p>sampling number along longitudinal axis</p>
</dd>
<dt>uvexten<span class="classifier">string, build during instantiation</span></dt><dd><p>naming extension with nU and nV like ‘_nU0100_nV0100’</p>
</dd>
<dt>t0<span class="classifier">numeric</span></dt><dd><p>reference time in the experiment, for building rectified sphi coordinates, also default for building pathlines</p>
</dd>
<dt>normalShift<span class="classifier">numeric (default=0)</span></dt><dd><p>shift to apply to meshes in pixel space along normal direction</p>
</dd>
<dt>a_fixed<span class="classifier">numeric (default=1)</span></dt><dd><p>aspect ratio for fixed-width pullbacks in uv and sphi coordinates</p>
</dd>
<dt>phiMethod<span class="classifier">str specifier (‘3dcurves’ or ‘texture’)</span></dt><dd><p>method for stabilizing the <code class="docutils literal notranslate"><span class="pre">v</span></code> axis: either use the geometry of the surface to minimize
surface deformation from timepoint to timepoint, so that v(t) for a given value of <code class="docutils literal notranslate"><span class="pre">u</span></code> is
very near v(t-1) at the same value of <code class="docutils literal notranslate"><span class="pre">u</span></code>.
This is a method for determining Phi map in pullback mesh creation, with
the full map from embedding to pullback being [M’=(Phi)o(Z)o(M)], where M is a nearly-conformal mapping to the
plane, Z changes the spacing of the longitudinal coordinates to reflect the average proper length traversed from
the ‘ring’ of u=const to the ‘ring’ of u=const+du.
This string specifier must be ‘3dcurves’ (geometric phi stabilization)
or ‘texture’ (optical flow phi stabilization)</p>
</dd>
<dt>endcapOptions<span class="classifier">struct with fields</span></dt><dd><dl>
<dt>adist<span class="classifier">numeric</span></dt><dd><p>distance around anterior point A which is removed from tubular mesh (sliced off)</p>
</dd>
<dt>pdist<span class="classifier">numeric</span></dt><dd><p>distance around anterior point P which is removed from tubular mesh (sliced off)</p>
</dd>
<dt>tref<span class="classifier">numeric</span></dt><dd><blockquote>
<div><p>timestamp for reference time used to define th point on the endcap</p>
</div></blockquote>
<p>at which we cut the cylinder mesh into a cylinderCutMesh (a topological disk/square).
This “dorsal” point for other timepoints are identified by pointmatching.</p>
</dd>
</dl>
<p>Additional fields allowed</p>
</dd>
<dt>plotting<span class="classifier">struct with fields</span></dt><dd><dl class="simple">
<dt>‘preview’<span class="classifier">bool (default=false)</span></dt><dd><p>display intermediate results</p>
</dd>
<dt>‘save_ims’<span class="classifier">bool (default=true)</span></dt><dd><p>save images along the way</p>
</dd>
<dt>‘xyzlim_um_buff’<span class="classifier">3x2 float</span></dt><dd><p>xyzlimits in um in RS coord sys with buffer</p>
</dd>
<dt>‘xyzlim_raw’<span class="classifier">3x2 float</span></dt><dd><p>xyzlimits in pixels</p>
</dd>
<dt>‘xyzlim_pix’<span class="classifier">3x2 float</span></dt><dd><p>xyzlimits in pixels, in rotated and translated coordinates</p>
</dd>
<dt>‘xyzlim_um’<span class="classifier">3x2 float</span></dt><dd><p>xyzlimits in um in rotated, translated, and scaled coordinate system</p>
</dd>
<dt>‘colors’<span class="classifier">Nx3 RGB values</span></dt><dd><p>color cycle for tubi</p>
</dd>
</dl>
</dd>
<dt>apdvPts = struct(‘anteriorPts’, [], …</dt><dd><p>‘posteriorPts’, [], …
‘antPts_sm’, [], …
‘postPts_sm’, [], …
‘dorsalPts’, [], …
‘antPts_rs’, [], …
‘postPts_rs’, [], …
‘dorsPts_rs’, [])</p>
</dd>
<dt>apdvOptions<span class="classifier">optional struct with fields</span></dt><dd><p>options used for finding APDV frame</p>
</dd>
<dt>currentTime<span class="classifier">numeric</span></dt><dd><p>timestamp, assigned whenever time is set</p>
</dd>
<dt>currentMesh = struct with fields</dt><dd><dl class="simple">
<dt>‘rawMesh’<span class="classifier">struct with fields</span></dt><dd><p>original mesh found by surface detection</p>
</dd>
<dt>‘alignedMesh’: struct with fields</dt><dd><p>APDV rotated and scaled mesh (raw mesh in APDV coordinates)</p>
</dd>
<dt>‘cylinderMesh’, [],</dt><dd><p>original mesh with endcaps cut off</p>
</dd>
<dt>‘cylinderMeshClean’, [],</dt><dd><p>cylinder mesh with “ears” removed (ears give difficulty in mapping to the plane)</p>
</dd>
<dt>‘cutMesh’, [],</dt><dd><p>cylinder mesh with a seam given by cutPath</p>
</dd>
<dt>‘cutPath’, [],</dt><dd><p>vertex indices of the cutMesh along which the periodic seam is cut</p>
</dd>
<dt>‘uvcutMesh’, [],</dt><dd><p>rectilinear cutMesh in (u,v) from Dirichlet map result to rectangle</p>
</dd>
<dt>‘spcutMesh’, [],</dt><dd><p>rectilinear cutMesh in (s,phi) ‘surface Lagrangian’ parameterization</p>
</dd>
<dt>‘spcutMeshSm’, [],</dt><dd><p>rectilinear cutMesh in (s,phi) smoothed in time</p>
</dd>
<dt>‘spcutMeshSmRS’, [],</dt><dd><p>rectilinear cutMesh in (s,phi) smoothed in time with rotated scaled embedding</p>
</dd>
<dt>‘spcutMeshSmRSC’, [],</dt><dd><p>rectilinear cutMesh as closed cylinder (topological annulus), in (s,phi) smoothed, with rotated scaled embedding</p>
</dd>
<dt>‘ricciMesh’<span class="classifier">struct with fields</span></dt><dd><p>ricci flow result pullback mesh, topological annulus</p>
</dd>
</dl>
</dd>
<dt>currentCline = struct(‘mss’, [], …</dt><dd><p>‘mcline’, [], …
‘avgpts’, []) ;</p>
</dd>
<dt>data = struct(‘adjustlow’, 0, …</dt><dd><p>‘adjusthigh’, 0, …
‘axisOrder’, [1 2 3], …
‘ilastikOutputAxisOrder’, ‘cxyz’) options for scaling and transposing image intensity data</p>
</dd>
<dt>currentData = struct(‘IV’, [], …</dt><dd><p>‘adjustlow’, 0, …
‘adjusthigh’, 0 )           image intensity data in 3d and scaling</p>
</dd>
<dt>currentVelocity<span class="classifier">struct with field</span></dt><dd><p>‘piv3d’ : struct with current timepoint’s PIV information in both 2d and 3d</p>
</dd>
<dt>piv<span class="classifier">struct with fields for all timepoints’ PIV information</span></dt><dd><dl class="simple">
<dt>‘imCoords’<span class="classifier">str specifier (default=’sp_sme’)</span></dt><dd><p>image coord system for measuring PIV / optical flow) ;</p>
</dd>
<dt>‘Lx’<span class="classifier">int</span></dt><dd><p>width of image, in pixels (x coordinate)</p>
</dd>
<dt>‘Ly’<span class="classifier">int</span></dt><dd><p>height of image, in pixels (y coordinate)</p>
</dd>
<dt>‘raw’<span class="classifier">struct</span></dt><dd><p>raw PIV results from disk/PIVLab</p>
</dd>
<dt>‘smoothed’ :</dt><dd><p>smoothed PIV results after gaussian blur</p>
</dd>
<dt>‘smoothing_sigma’ numeric (default=1 )</dt><dd><p>sigma of gaussian smoothing on PIV, in units of PIV sampling grid pixels</p>
</dd>
</dl>
</dd>
<dt>velocityAverage<span class="classifier">struct with fields</span></dt><dd><dl>
<dt>vsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 3 float array</span></dt><dd><p>3d velocities at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vfsmM<span class="classifier">(#timePoints-1) x (2*nU*(nV-1)) x 3 float array</span></dt><dd><p>3d velocities at face barycenters in um/dt rs</p>
</dd>
<dt>vnsmM<span class="classifier">(#timePoints-1) x (nX*nY) float array</span></dt><dd><p>normal velocity at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vvsmM<span class="classifier">(#timePoints-1) x (nU*nV) x 3 float array</span></dt><dd><p>3d velocities at (1x resolution) mesh vertices in um/min rs</p>
</dd>
<dt>v2dsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><p>2d velocities at PIV evaluation coordinates in pixels/ min</p>
</dd>
<dt>v2dsmMum<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><blockquote>
<div><p>2d velocities at PIV evaluation coordinates in scaled pix/min, but
proportional to um/min (scaled by dilation of map)</p>
</div></blockquote>
<dl class="simple">
<dt>‘v3d’</dt><dd><p>3D velocities in embedding space [pix/dt]</p>
</dd>
<dt>‘v2d’</dt><dd><p>2D tangential velocities in pullback</p>
</dd>
<dt>‘v2dum’</dt><dd><p>2D tangential velocity scaled by speed in true embedding space</p>
</dd>
<dt>‘vn’</dt><dd><p>normal velocity in spaceUnits per timeInterval timeUnits</p>
</dd>
<dt>‘vf’</dt><dd><p>velocity vielf on face barycenters after Lagrangian avg</p>
</dd>
<dt>‘vv’, []) ;</dt><dd><p>velocity field on vertices after Lagrangian avg</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>cleanCntrlines :</dt><dd><p>centerlines in embedding space after temporal averaging</p>
</dd>
<dt>smoothing<span class="classifier">struct with fields</span></dt><dd><dl class="simple">
<dt>‘lambda’<span class="classifier">float (default=0.00)</span></dt><dd><p>diffusion const for field smoothing on mesh, if nonzero</p>
</dd>
<dt>‘lambda_mesh’<span class="classifier">float (default=0.00)</span></dt><dd><p>diffusion const for vertex smoothing of mesh itself, if nonzero</p>
</dd>
<dt>‘nmodes’<span class="classifier">int (default=7)</span></dt><dd><p>number of low freq modes to keep per DV hoop</p>
</dd>
<dt>‘zwidth’<span class="classifier">int (default=1)</span></dt><dd><p>half-width of tripulse filter applied along zeta/z/s/u direction in pullback space, in units of du/dz/ds/dzeta</p>
</dd>
</dl>
</dd>
<dt>pathlines<span class="classifier">struct with fields</span></dt><dd><dl class="simple">
<dt>‘t0’<span class="classifier">numeric</span></dt><dd><p>time at which pathlines are rectilinear (from which time the points are advected).
This is a timestamp (not an index) at which pathlines form regular grid in space.</p>
</dd>
<dt>‘refMesh’</dt><dd><p>reference mesh for pathline advection</p>
</dd>
<dt>‘piv’, []</dt><dd><p>Lagrangian pathlines from piv coords</p>
</dd>
<dt>‘vertices’, [],</dt><dd><p>Lagrangian pathlines from mesh vertices</p>
</dd>
<dt>‘vertices3d’,</dt><dd><p>Lagrangian pathlines from mesh vertices</p>
</dd>
<dt>‘faces’, [],</dt><dd><p>Lagrangian pathlines from mesh face barycenters</p>
</dd>
<dt>‘beltrami’, struct with fields for beltrami coefficient evaluated along pathlines</dt><dd><p>‘mu_material’, [], …
‘mu_material_filtered’, [], …
‘mu_material_vertices’, [], …
‘fitlerOptions’, struct with fields describing filtering</p>
</dd>
</dl>
</dd>
<dt>currentStrain<span class="classifier">struct with fields</span></dt><dd><dl class="simple">
<dt>‘pathline’ :</dt><dd><p>strain from pathlines</p>
</dd>
<dt>struct(‘t0Pathlines’, [], …</dt><dd><p>t=0 timepoint for pathlines in question</p>
</dd>
<dt>‘strain’ :</dt><dd><p>strain evaluated along pathlines</p>
</dd>
<dt>‘beltrami’ :</dt><dd><p>beltrami coefficient for pathlines</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="module-@TubULAR">
<span id="full-contents"></span><h1>Full Contents:<a class="headerlink" href="#module-@TubULAR" title="Permalink to this headline">#</a></h1>
<dl class="mat class">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">TubULAR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">xp</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref mat mat-class docutils literal notranslate"><span class="pre">handle</span></code></p>
<p>Tube-like sUrface Lagrangian Analysis Resource (TubULAR) class.
Note that TubULAR is fully documented, with docs accessible via:</p>
<blockquote>
<div><p>doc TubULAR</p>
</div></blockquote>
<dl class="simple">
<dt>uv<span class="classifier">(conformal map onto unit square, with one fixed vertex at each</span></dt><dd><p>endcap)
Conformally mapping the cylinderCutMesh onto the unit square
in the plane results in the instantaneous uv coordinate system.
Corners of the unit square are taken directly from the cutMesh,
so are liable to include some overall twist.</p>
</dd>
<dt>sphi<span class="classifier">(proper length x rectified azimuthal coordinate)</span></dt><dd><p>quasi-axisymmetric system in which first coordinate is
proper length along surface and second is a rectified azimuthal
coordinate. Rectification means that the surface is rotated as
v-&gt;phi(s), where each s coordinate is offset by a “rotation”
about the surface along a direction that is perpendicular to s
in pullback space. This rectification may be based on surface
positions in R^3 (geometric) or based on intensity motion in
pullback space (material/Lagrangian) inferred through
phasecorrelation of tissue strips around discretized s values.</p>
</dd>
<dt>r/spr/sphir<span class="classifier">(proper length x rectified azimuthal coordinate)</span></dt><dd><p>same as sphi but with aspect ratio relaxed to minimize isoareal
energy cost –&gt; makes triangles more similar in area by scaling
the s axis (longitudinal axis) by a scalar factor.</p>
</dd>
<dt>iLastik’s coordinate systems<span class="classifier">I recommend using cxyz as the axis</span></dt><dd><p>when outputting from iLastik. For our setup, this will mean
that the meshes are mirrored with respect to the lab frame, so
tubi.flipy = true.</p>
</dd>
<dt>PIV measurements:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘piv’: principal surface-Lagrangian-frame PIV (sp_sme or up_sme)</dt><dd><p>–&gt; note that the designation of coordinate system is not
explicitly specified in the filenames:
tubi.dir.mesh/gridCoords_nU0100_nV0100/piv/piv3d, etc</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>imSize        : 2x1 int, size of pullback images to create
xyzlim        : 3x2 float, mesh limits in full resolution pixels, in data space
xyzlim_um     : 3x2 float, mesh limits in lab APDV frame in microns
resolution    : float, resolution of pixels in um
rot           : 3x3 float, APDV rotation matrix
trans         : 3x1 float, APDV translation
a_fixed       : float, aspect ratio for fixed-width pullbacks
phiMethod     : str, ‘3dcurves’ or ‘texture’
flipy         : bool, APDV coord system is mirrored XZ wrt raw data
nV            : int, sampling number along circumferential axis
nU            : int, sampling number along longitudinal axis
uvexten       : str, naming extension with nU and nV like ‘_nU0100_nV0100’
t0            : int, reference timePoint in the experiment
velocityAverage : struct with fields</p>
<blockquote>
<div><dl class="simple">
<dt>vsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 3 float array</span></dt><dd><p>3d velocities at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vfsmM<span class="classifier">(#timePoints-1) x (2*nU*(nV-1)) x 3 float array</span></dt><dd><p>3d velocities at face barycenters in um/dt rs</p>
</dd>
<dt>vnsmM<span class="classifier">(#timePoints-1) x (nX*nY) float array</span></dt><dd><p>normal velocity at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vvsmM<span class="classifier">(#timePoints-1) x (nU*nV) x 3 float array</span></dt><dd><p>3d velocities at (1x resolution) mesh vertices in um/min rs</p>
</dd>
<dt>v2dsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><p>2d velocities at PIV evaluation coordinates in pixels/ min</p>
</dd>
<dt>v2dsmMum<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><p>2d velocities at PIV evaluation coordinates in scaled pix/min, but
proportional to um/min (scaled by dilation of map)</p>
</dd>
</dl>
</div></blockquote>
<p>QuapSlap allows the user to designate the AP axis, a DV axis, and a
centerline for the segmented object.
To designate APDV coordinate system, use iLastik training on the
timepoint t0 (which is an attribute of tubi). In particular, train on
anterior (A), posterior (P), background (B), and dorsal (D) location
in different iLastik channels. Small blobs of high probability near
the anterior end for A, somewhere along the posterior end for P, and
anywhere along dorsal for D are best. Then the centers of mass of
thresholded contiguous high probability are computed for each to
define the coordinate system. By default, the ilastik results are
read as ch1=A, ch2=P, ch3=B, ch4=D, but anteriorChannel,
posteriorChannel, and dorsalChannel specify the iLastik
training channel that is used for each specification.
Name the h5 file output from iLastik as
…_Probabilities_APDVcoords.h5
For example, dorsal for the gut was chosen at the fused site where
additional 48YGAL4-expressing muscle-like cells form a seam.
Posterior is at the rear of the yolk, where the endoderm closes, for
apical surface training. Anterior is at the junction of the midgut
with the foregut.
Separately, define the AP points for centerline extraction. For most gut
data, the posterior point is different in centerline than it is for AP
centerline specification, so we use a different ILP to train for A and P
for all timepoints of dynamic data.</p>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.APDV">
<span class="sig-name descname"><span class="pre">APDV</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'resolution',</span> <span class="pre">[],</span> <span class="pre">\n'rot',</span> <span class="pre">[],</span> <span class="pre">\n'trans',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.APDV" title="Permalink to this definition">#</a></dt>
<dd><p>translation vector to transform data into APDV frame (rot*v+trans)*resolution</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.APDV2dxyz">
<span class="sig-name descname"><span class="pre">APDV2dxyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.APDV2dxyz" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d vectors from APDV coord sys to XYZ data space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.APDV2xyz">
<span class="sig-name descname"><span class="pre">APDV2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.APDV2xyz" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d coords from APDV coord sys to XYZ data space</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.XY2uv">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">XY2uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">XY</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.XY2uv" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Map pixel positions (1, sizeImX) and (1, sizeImY) to
(0, umax) and (0, vmax) of pullback space if singleCover,
or y coords are mapped to (-0.5, 1.5)*vmax if doubleCover</p>
</div></blockquote>
<p>NOTE THAT MAP IS
[xesz, yesz] = [size(im, 1), size(im, 2)]
uv(:, 1) = umax * (XY(:, 1) - 1) / xesz ;
uv(:, 2) = vmax * 2.0 * (XY(:, 2) - 1) / yesz - 0.5 ;</p>
<p>NOTE THAT INVERSE MAP IS
x–&gt; (xy(:, 1) * (Xsz-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (Ysz-1)) / (2*vmax) + 1 + (Ysz-1)*0.25 ;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">2</span> <span class="pre">ints</span> <span class="pre">for</span> <span class="pre">size</span></code></span>) – image in which pixel coordinates are defined or dimensions
of the image (pullback image in pixels)</p></li>
<li><p><strong>XY</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Qx2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – pixel coordinates to convert to pullback space</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uv</strong> – pullback coordinates of input pixel coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Qx2 numeric array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.a_fixed">
<span class="sig-name descname"><span class="pre">a_fixed</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#@TubULAR.TubULAR.a_fixed" title="Permalink to this definition">#</a></dt>
<dd><p>aspect ratio for fixed geometry pullback meshes</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.adjustIV">
<span class="sig-name descname"><span class="pre">adjustIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">IV</span></em>, <em class="sig-param"><span class="pre">adjustlow</span></em>, <em class="sig-param"><span class="pre">adjusthigh</span></em>, <em class="sig-param"><span class="pre">forceValues</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.adjustIV" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>IV</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">3D</span> <span class="pre">numeric</span> <span class="pre">(optional,</span> <span class="pre">loads</span> <span class="pre">currentData</span> <span class="pre">if</span> <span class="pre">empty)</span></code></span>) – data to adjust</p></li>
<li><p><strong>adjustlow</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">numeric</span> <span class="pre">or</span> <span class="pre">#channels</span> <span class="pre">x</span> <span class="pre">1</span> <span class="pre">numeric</span></code></span>) – minimum intensity or percent intensity to adjust data</p></li>
<li><p><strong>adjusthigh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">numeric</span> <span class="pre">or</span> <span class="pre">#channels</span> <span class="pre">x</span> <span class="pre">1</span> <span class="pre">numeric</span></code></span>) – maximum intensity or percent intensity to adjust data</p></li>
<li><p><strong>forceValues</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">enforce</span> <span class="pre">the</span> <span class="pre">adjustlow/high</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">intensity</span></code></span>) – </p></li>
<li><p><strong>values</strong> – </p></li>
<li><p><strong>percentile</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">not</span></code></span>) – </p></li>
<li><p><strong>100.</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">even</span> <span class="pre">if</span> <span class="pre">&lt;</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.apdvOptions">
<span class="sig-name descname"><span class="pre">apdvOptions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.apdvOptions" title="Permalink to this definition">#</a></dt>
<dd><p>Options for computing the APDV frame</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.cleanFMCenterlines">
<span class="sig-name descname"><span class="pre">cleanFMCenterlines</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.cleanFMCenterlines" title="Permalink to this definition">#</a></dt>
<dd><p>centerlines from fast marching method (crude centerlines) in embedding space, no temporal filtering</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.clearTime">
<span class="sig-name descname"><span class="pre">clearTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.clearTime" title="Permalink to this definition">#</a></dt>
<dd><p>clear current timepoint’s data for tubi instance</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.clipXY">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">clipXY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">xx</span></em>, <em class="sig-param"><span class="pre">yy</span></em>, <em class="sig-param"><span class="pre">Lx</span></em>, <em class="sig-param"><span class="pre">Ly</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.clipXY" title="Permalink to this definition">#</a></dt>
<dd><p>Clip x at (1, Lx) and clip Y as periodic (1=Ly, Ly=1), for
image that is periodic in Y. Consider Y in [1, Ly]. If the
pullback is a doubleCover, Ly = 2*mesh width in pixels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xx</strong> – </p></li>
<li><p><strong>yy</strong> – </p></li>
<li><p><strong>Lx</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – number of pixels along x dimension</p></li>
<li><p><strong>Ly</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – number of pixels along y dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>[xx, yy]</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>x and y coordinates clipped to [1, Lx] and [1, Ly]</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.currentData">
<span class="sig-name descname"><span class="pre">currentData</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'IV',</span> <span class="pre">[],</span> <span class="pre">\n'adjustlow',</span> <span class="pre">0,</span> <span class="pre">\n'adjusthigh',</span> <span class="pre">0</span> <span class="pre">)"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.currentData" title="Permalink to this definition">#</a></dt>
<dd><p>image intensity data in 3d and scaling</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.currentMesh">
<span class="sig-name descname"><span class="pre">currentMesh</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'rawMesh',</span> <span class="pre">[],</span> <span class="pre">\n'alignedMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cylinderMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cylinderMeshClean',</span> <span class="pre">[],</span> <span class="pre">\n'cutMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cutPath',</span> <span class="pre">[],</span> <span class="pre">\n'uvcutMesh',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMesh',</span> <span class="pre">[],</span>         <span class="pre">%</span> <span class="pre">rectilinear</span> <span class="pre">cutMesh</span> <span class="pre">in</span> <span class="pre">(s,phi)</span> <span class="pre">'surface</span> <span class="pre">Lagrangian'</span> <span class="pre">parameterization\n'spcutMeshSm',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMeshSmRS',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMeshSmRSC',</span> <span class="pre">[],</span> <span class="pre">\n'ricciMesh',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.currentMesh" title="Permalink to this definition">#</a></dt>
<dd><p>ricci flow result pullback mesh, topological annulus</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.currentStrain">
<span class="sig-name descname"><span class="pre">currentStrain</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'pathline',</span> <span class="pre">\nstruct('t0Pathlines',</span> <span class="pre">[],</span> <span class="pre">\n'strain',</span> <span class="pre">[],</span> <span class="pre">\n'beltrami',</span> <span class="pre">[]))"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.currentStrain" title="Permalink to this definition">#</a></dt>
<dd><p>beltrami coefficient for pathlines</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.currentTime">
<span class="sig-name descname"><span class="pre">currentTime</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.currentTime" title="Permalink to this definition">#</a></dt>
<dd><p>int, the timepoint of the current frame under examination (this can be set with setTime and changes during many method calls)</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.dXY2duv">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">dXY2duv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">dXY</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.dXY2duv" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>XY2uv(im, XY, doubleCovered, umax, vmax)</dt><dd><p>Map difference in pixel positions defined on
(1, sizeImX) and (1, sizeImY) to
(0, umax) and (0, vmax) of pullback space if singleCover,
or y coords are mapped to (-0.5, 1.5)*vmax if doubleCover</p>
</dd>
</dl>
<p>NOTE THAT FULL COORDINATE MAP IS
[xesz, yesz] = [size(im, 1), size(im, 2)]
uv(:, 1) = umax * (XY(:, 1) - 1) / xesz ;
uv(:, 2) = vmax * 2.0 * (XY(:, 2) - 1) / yesz - 0.5 ;</p>
<p>NOTE THAT INVERSE MAP IS
x–&gt; (xy(:, 1) * (Xsz-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (Ysz-1)) / (2*vmax) + 1 + (Ysz-1)*0.25 ;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">2</span> <span class="pre">ints</span> <span class="pre">for</span> <span class="pre">size</span></code></span>) – image in which pixel coordinates are defined or dimensions
of the image (pullback image in pixels)</p></li>
<li><p><strong>dXY</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Qx2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – difference in pixel coordinates as vector, to convert to
pullback space</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uv</strong> – pullback coordinates of input pixel coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Qx2 numeric array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.data">
<span class="sig-name descname"><span class="pre">data</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'adjustlow',</span> <span class="pre">0,</span> <span class="pre">\n'adjusthigh',</span> <span class="pre">0,</span> <span class="pre">\n'axisOrder',</span> <span class="pre">[1</span> <span class="pre">2</span> <span class="pre">3],</span> <span class="pre">\n'ilastikOutputAxisOrder',</span> <span class="pre">'cxyz')"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.data" title="Permalink to this definition">#</a></dt>
<dd><p>options for scaling and transposing image intensity data</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.dir">
<span class="sig-name descname"><span class="pre">dir</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.dir" title="Permalink to this definition">#</a></dt>
<dd><p>str, directory where QuapSlap data lives</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.doubleCoverPullbackImages">
<span class="sig-name descname"><span class="pre">doubleCoverPullbackImages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.doubleCoverPullbackImages" title="Permalink to this definition">#</a></dt>
<dd><p>options : struct with fields
coordsys : (‘sp’, ‘uv’, ‘up’)</p>
<blockquote>
<div><p>coordinate system to make double cover</p>
</div></blockquote>
<dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>whether to overwrite current images on disk</p>
</dd>
<dt>histeq<span class="classifier">bool, default=true</span></dt><dd><p>perform histogram equilization during pullback
extension</p>
</dd>
<dt>ntiles<span class="classifier">int, default=50</span></dt><dd><p>The number of bins in each dimension for histogram equilization for a
square original image. That is, the extended image will have (a_fixed *
ntiles, 2 * ntiles) bins in (x,y).</p>
</dd>
<dt>a_fixed<span class="classifier">float, default=tubi.a_fixed</span></dt><dd><p>The aspect ratio of the pullback image: Lx / Ly</p>
</dd>
</dl>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.doubleToSingleCover">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">doubleToSingleCover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">XY</span></em>, <em class="sig-param"><span class="pre">Ly</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.doubleToSingleCover" title="Permalink to this definition">#</a></dt>
<dd><p>detect if XY is passed as a pair of grids</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.dvAverageNematic">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">dvAverageNematic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">magnitude</span></em>, <em class="sig-param"><span class="pre">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.dvAverageNematic" title="Permalink to this definition">#</a></dt>
<dd><p>[mag_ap, theta_ap] = DVAVERAGENEMATIC(magnitude, theta)
Given a nematic field defined on a rectilinear grid, with
Q(i,j) being in the ith ap position and jth dv position,
average the nematic field over the dv positions (dimension 2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">nU</span> <span class="pre">x</span> <span class="pre">nV</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – magnitude of nematic field in 2D rectilinear grid</p></li>
<li><p><strong>theta</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">nU</span> <span class="pre">x</span> <span class="pre">nV</span> <span class="pre">float</span> <span class="pre">array,</span> <span class="pre">with</span> <span class="pre">values</span> <span class="pre">as</span> <span class="pre">angles</span> <span class="pre">in</span> <span class="pre">radians</span></code></span>) – angle (mod pi) of nematic field in 2D rectilinear grid</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mag_ap</strong> (<em>nU x 1 float array</em>) – average magnitude of nematic field along the ap dimension</p></li>
<li><p><strong>theta_ap</strong> (<em>nU x 1 float array</em>) – average angle (mod pi) of nematic field along the ap
dimension</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.dx2APDV">
<span class="sig-name descname"><span class="pre">dx2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">da</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.dx2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>dars = dx2APDV(tubi, da)
Transform 3d difference vector from XYZ data space to APDV
coord sys</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.dynamic">
<span class="sig-name descname"><span class="pre">dynamic</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.dynamic" title="Permalink to this definition">#</a></dt>
<dd><p>expMeta : struct with fields
fileMeta : struct with fields</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.endcapOptions">
<span class="sig-name descname"><span class="pre">endcapOptions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.endcapOptions" title="Permalink to this definition">#</a></dt>
<dd><p>the full map from embedding to pullback being [M’=(Phi)o()o()].
This string specifier must be ‘3dcurves’ (geometric phi stabilization)
or ‘texture’ (optical flow phi stabilization)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.fileBase">
<span class="sig-name descname"><span class="pre">fileBase</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.fileBase" title="Permalink to this definition">#</a></dt>
<dd><p>fileNames to be populated by timestamp (’…%06dmat’)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.fileName">
<span class="sig-name descname"><span class="pre">fileName</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.fileName" title="Permalink to this definition">#</a></dt>
<dd><p>fileName struct with fields such as rot, trans, etc where measurements/parameters are stored on disk</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.flipy">
<span class="sig-name descname"><span class="pre">flipy</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.flipy" title="Permalink to this definition">#</a></dt>
<dd><p>whether data is mirror image of lab frame coordinates</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.fullFileBase">
<span class="sig-name descname"><span class="pre">fullFileBase</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.fullFileBase" title="Permalink to this definition">#</a></dt>
<dd><p>full path of filenames (like fullfile(tubi.dir.X, tubi.fileBase.X))</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getAPpointsSm">
<span class="sig-name descname"><span class="pre">getAPpointsSm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getAPpointsSm" title="Permalink to this definition">#</a></dt>
<dd><p>Load the anterior and posterior ‘centers of mass’ ie the
endpoints of the object’s centerline</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentCutMesh">
<span class="sig-name descname"><span class="pre">getCurrentCutMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentCutMesh" title="Permalink to this definition">#</a></dt>
<dd><p>Load/recall the current cutMesh with pullback uv coordinates.
This mesh is not a rectilinear mesh topology with vertices in
an nU x nV grid, but instead has the topology of the mesh
found from getMeshes after cutting.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentPathlineStrain">
<span class="sig-name descname"><span class="pre">getCurrentPathlineStrain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0Pathlines</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentPathlineStrain" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">current</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>t0Pathlines</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">or</span> <span class="pre">empty</span></code></span>) – reference timepoint. If empty, set to tubi.t0set()</p></li>
<li><p><strong>varargin</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">strings</span> <span class="pre">('strain',</span> <span class="pre">'beltrami')</span></code></span>) – which strain measures to load from disk and attribute to
self</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>strain</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tubi.currentStrain.pathline</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentSegmentation2D">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentSegmentation2D" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pullback space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentSegmentation2DCorrected">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation2DCorrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentSegmentation2DCorrected" title="Permalink to this definition">#</a></dt>
<dd><p>Decide on coordinate system for corrected pullback binary</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentSegmentation3D">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentSegmentation3D" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pushforward space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getCurrentSegmentation3DCorrected">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation3DCorrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getCurrentSegmentation3DCorrected" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pullback space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getPIV">
<span class="sig-name descname"><span class="pre">getPIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getPIV" title="Permalink to this definition">#</a></dt>
<dd><p>Load PIV results and store in tubi.piv if not already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getPathlineStrain">
<span class="sig-name descname"><span class="pre">getPathlineStrain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getPathlineStrain" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – t0Pathlines : int  (default = t0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>strain</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>#tps x nFaces x 2 x 2 float array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getPullbackPathlines">
<span class="sig-name descname"><span class="pre">getPullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getPullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><p>Discern if we must load pathlines or if already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getRadii">
<span class="sig-name descname"><span class="pre">getRadii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getRadii" title="Permalink to this definition">#</a></dt>
<dd><p>Load radii from disk in specified coordinate system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>coordSys: str specifier for how to return radii</dt><dd><p>’spcutMeshSmRSC’ –&gt; return nU x (nV-1) array for radii
of vertices in spcutMeshSmRSC embedding
&lt;add other options here&gt;</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getRotTrans">
<span class="sig-name descname"><span class="pre">getRotTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getRotTrans" title="Permalink to this definition">#</a></dt>
<dd><p>Load the translation to put anterior to origin and AP axis
along x axis</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getVelocityAverage">
<span class="sig-name descname"><span class="pre">getVelocityAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getVelocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getVelocityRaw">
<span class="sig-name descname"><span class="pre">getVelocityRaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getVelocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getVelocitySimpleAverage">
<span class="sig-name descname"><span class="pre">getVelocitySimpleAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getVelocitySimpleAverage" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.getXYZLims">
<span class="sig-name descname"><span class="pre">getXYZLims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.getXYZLims" title="Permalink to this definition">#</a></dt>
<dd><p>[raw, pix, um, um_buff] = GETXYZLIMS(tubi)
Grab each xyzlim from self, otherwise load from disk
full resolution pix</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.imSize">
<span class="sig-name descname"><span class="pre">imSize</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.imSize" title="Permalink to this definition">#</a></dt>
<dd><p>size of pullback images to create (default is [a_ratio * 1000, 1000])</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.invertRotation">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">invertRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rot</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.invertRotation" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain rotation matrix that undoes the APDV rotation</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadCurrentCutMesh">
<span class="sig-name descname"><span class="pre">loadCurrentCutMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadCurrentCutMesh" title="Permalink to this definition">#</a></dt>
<dd><p>Load the current cutMesh with pullback uv coordinates.
This mesh is not a rectilinear mesh topology with vertices in
an nU x nV grid, but instead has the topology of the mesh
found from getMeshes after cutting.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadPIV">
<span class="sig-name descname"><span class="pre">loadPIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadPIV" title="Permalink to this definition">#</a></dt>
<dd><p>Load PIV results from disk and store in tubi.piv</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadPullbackPathlines">
<span class="sig-name descname"><span class="pre">loadPullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadPullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadVelocityAverage">
<span class="sig-name descname"><span class="pre">loadVelocityAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadVelocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>Retreive the Velocity on each vertex/face barycenter of the
(s,phi) meshes.
NOTE: that these are nearly Lagrangian for most applications,
but not perfectly Lagrangian. See also:
tubi.getPullbackPathlines(t0), which corrects for any
residual motion in the pullback plane.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadVelocityRaw">
<span class="sig-name descname"><span class="pre">loadVelocityRaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadVelocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>Load and pack into struct</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.loadVelocitySimpleAverage">
<span class="sig-name descname"><span class="pre">loadVelocitySimpleAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.loadVelocitySimpleAverage" title="Permalink to this definition">#</a></dt>
<dd><p>Load and pack into struct</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.manualTrackingAdd">
<span class="sig-name descname"><span class="pre">manualTrackingAdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.manualTrackingAdd" title="Permalink to this definition">#</a></dt>
<dd><p>Add to current tracks on disk</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.measureRMSvelocityOverTime">
<span class="sig-name descname"><span class="pre">measureRMSvelocityOverTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.measureRMSvelocityOverTime" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – weights : weights to attribute to each face in mesh
coordSys : str specifier (default==’sp’)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vrms</strong> (<em>#tps x 1 float array</em>) – rms velocity over time</p></li>
<li><p><strong>timestamps</strong> (<em>#tps x 1 float array</em>) – timestamps associated with each entry</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.nU">
<span class="sig-name descname"><span class="pre">nU</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.nU" title="Permalink to this definition">#</a></dt>
<dd><p>sampling number along longitudinal axis</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.nV">
<span class="sig-name descname"><span class="pre">nV</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.nV" title="Permalink to this definition">#</a></dt>
<dd><p>sampling number along circumferential axis</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.normalShift">
<span class="sig-name descname"><span class="pre">normalShift</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0'</span></em><a class="headerlink" href="#@TubULAR.TubULAR.normalShift" title="Permalink to this definition">#</a></dt>
<dd><p>shift to apply to meshes in pixel space along normal direction</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.phiMethod">
<span class="sig-name descname"><span class="pre">phiMethod</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'3dcurves'"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.phiMethod" title="Permalink to this definition">#</a></dt>
<dd><p>method for determining Phi map in pullback mesh creation, with</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.piv">
<span class="sig-name descname"><span class="pre">piv</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>             <span class="pre">'imCoords',</span> <span class="pre">'sp_sme',</span> <span class="pre">\n'Lx',</span> <span class="pre">[],</span> <span class="pre">\n'Ly',</span> <span class="pre">[],</span> <span class="pre">\n'raw',</span> <span class="pre">struct(),</span> <span class="pre">\n'smoothed',</span> <span class="pre">struct(),</span> <span class="pre">\n'smoothing_sigma',</span> <span class="pre">1</span> <span class="pre">)"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.piv" title="Permalink to this definition">#</a></dt>
<dd><p>sigma of gaussian smoothing on PIV, in units of PIV sampling grid pixels</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.plotPathlineBeltramiKymograph">
<span class="sig-name descname"><span class="pre">plotPathlineBeltramiKymograph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0Pathlines</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.plotPathlineBeltramiKymograph" title="Permalink to this definition">#</a></dt>
<dd><p>Example usage for 2021 gut paper:
options = struct(‘ylim’, [0, 2] )
tubi.plotPathlineBeltramiKymograph([], options)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.plotting">
<span class="sig-name descname"><span class="pre">plotting</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'preview',</span> <span class="pre">false,</span> <span class="pre">\n'save_ims',</span> <span class="pre">true,</span> <span class="pre">\n'xyzlim_um_buff',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_raw',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_pix',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_um',</span> <span class="pre">[],</span> <span class="pre">\n'colors',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.plotting" title="Permalink to this definition">#</a></dt>
<dd><p>adist : distance around anterior point A which is removed from tubular mesh (sliced off)
pdist : distance around anterior point P which is removed from tubular mesh (sliced off)
tref : reference time used to define th point on the endcap</p>
<blockquote>
<div><p>at which we cut the cylinder mesh into a cylinderCutMesh (a topological disk/square).
This “dorsal” point for other timepoints are identified by pointmatching.</p>
</div></blockquote>
<p>Additional fields allowed :</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.quarterIndicesDV">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">quarterIndicesDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nV</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.quarterIndicesDV" title="Permalink to this definition">#</a></dt>
<dd><p>[dorsal, ventral, left, right] = quarterIndicesDV(nV)
indices for each quarter of a DV section in grid coordinates</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.samplePullbackPathlines">
<span class="sig-name descname"><span class="pre">samplePullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">XY0</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.samplePullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><p>[p2d, p3d] = samplePullbackPathlines(tubi, XY0, options)
start at XY0, folow flow using barycentric coordinates of PIV
pullback pathlines. This is the same as advecting along a
fixed Langrangian coordinate.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.setDataLimits">
<span class="sig-name descname"><span class="pre">setDataLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">adjustlow_pctile</span></em>, <em class="sig-param"><span class="pre">adjusthigh_pctile</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.setDataLimits" title="Permalink to this definition">#</a></dt>
<dd><p>Use timepoint (tp) to obtain hard values for intensity limits
so that data is rescaled to fixed limits instead of
percentile. This is useful to avoid flickering of overall
intensity in data in which a few voxels vary a lot in
intensity.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.setTime">
<span class="sig-name descname"><span class="pre">setTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.setTime" title="Permalink to this definition">#</a></dt>
<dd><p>Set the current time of the dataset and clear current data
which was associated with the previously considered time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tt</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">or</span> <span class="pre">float</span></code></span>) – timePoint to set to be current, from available times in
tubi.xp.fileMeta.timePoints</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.smoothing">
<span class="sig-name descname"><span class="pre">smoothing</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'lambda',</span> <span class="pre">0.00,</span> <span class="pre">\n'lambda_mesh',</span> <span class="pre">0.00,</span> <span class="pre">\n'nmodes',</span> <span class="pre">7,</span> <span class="pre">\n'zwidth',</span> <span class="pre">1)"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.smoothing" title="Permalink to this definition">#</a></dt>
<dd><p>half-width of tripulse filter applied along zeta/z/s/u direction in pullback space, in units of du/dz/ds/dzeta</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.spaceUnits">
<span class="sig-name descname"><span class="pre">spaceUnits</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'$\\mu$m'"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.spaceUnits" title="Permalink to this definition">#</a></dt>
<dd><p>units of the embedding space (ex ‘$mu$m’)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.ssfactor">
<span class="sig-name descname"><span class="pre">ssfactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.ssfactor" title="Permalink to this definition">#</a></dt>
<dd><p>subsampling factor for probabilities</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.t0">
<span class="sig-name descname"><span class="pre">t0</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.t0" title="Permalink to this definition">#</a></dt>
<dd><p>reference time in the experiment</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.t0set">
<span class="sig-name descname"><span class="pre">t0set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.t0set" title="Permalink to this definition">#</a></dt>
<dd><p>t0set(tubi, t0) Set time offset from file or manually.
If t0 is saved to disk, it should have a header like:
# reference time for dataset
76
&lt;eof&gt;
and should be saved at tubi.fileName.t0</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.timeInterval">
<span class="sig-name descname"><span class="pre">timeInterval</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#@TubULAR.TubULAR.timeInterval" title="Permalink to this definition">#</a></dt>
<dd><p>increment in time between timepoints with</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.timeUnits">
<span class="sig-name descname"><span class="pre">timeUnits</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'min'"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.timeUnits" title="Permalink to this definition">#</a></dt>
<dd><p>indices differing by 1. For example, if
timePoints are [0,1,2,4] and these are
[1,1,2] minutes apart, then timeInterval
is 1.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.uv2APDV">
<span class="sig-name descname"><span class="pre">uv2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">uv</span></em>, <em class="sig-param"><span class="pre">coordSys</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.uv2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>Convert (u,v) pullback coordinates to xyz coordinates in the
APDV frame (rotated and scaled frame aligned with AP axis
along x and DV axis along z)</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.uv2XY">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">uv2XY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">uv</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.uv2XY" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>XY = uv2XY(im, uv, doubleCovered, umax, vmax)</dt><dd><p>Map from pullback uv u=(0,1), v=(0,1) to pixel XY</p>
</dd>
</dl>
<p>x–&gt; (xy(:, 1) * (size(im, 2)-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (size(im, 1)-1)) / (2*vmax) + 0.75 + (size(im,1)-1)*0.25</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">length(2)</span> <span class="pre">int</span> <span class="pre">array</span></code></span>) – 2D image into whose pixel space to map or size(im)</p></li>
<li><p><strong>uv</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Q*2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – mesh coordinates to convert to pullback pixel space (XY)</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>XY</strong> – positions of uv coordinates in pullback pixel space</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x 2 float array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.uvexten">
<span class="sig-name descname"><span class="pre">uvexten</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.uvexten" title="Permalink to this definition">#</a></dt>
<dd><p>naming extension with nU and nV like ‘_nU0100_nV0100’</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.velocityAverage">
<span class="sig-name descname"><span class="pre">velocityAverage</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'v3d',</span> <span class="pre">[],</span> <span class="pre">\n'v2d',</span> <span class="pre">[],</span> <span class="pre">\n'v2dum',</span> <span class="pre">[],</span> <span class="pre">\n'vn',</span> <span class="pre">[],</span> <span class="pre">\n'vf',</span> <span class="pre">[],</span> <span class="pre">\n'vv',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.velocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>velocity field on vertices after Lagrangian avg</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.velocityRaw">
<span class="sig-name descname"><span class="pre">velocityRaw</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'v3d',</span> <span class="pre">[],</span> <span class="pre">\n'v2d',</span> <span class="pre">[],</span> <span class="pre">\n'v2dum',</span> <span class="pre">[],</span> <span class="pre">\n'vn',</span> <span class="pre">[],</span> <span class="pre">\n'vf',</span> <span class="pre">[],</span> <span class="pre">\n'vv',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.TubULAR.velocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>velocity field on vertices, no temporal filtering</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.xp">
<span class="sig-name descname"><span class="pre">xp</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.TubULAR.xp" title="Permalink to this definition">#</a></dt>
<dd><p>struct with fields or ImSAnE experiment class instance</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.TubULAR.xyz2APDV">
<span class="sig-name descname"><span class="pre">xyz2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.TubULAR.xyz2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d coords from XYZ data space to APDV coord sys</p>
</dd></dl>
</dd></dl>
<dl class="mat class">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">Tubular_local_keep_these_changes_incorporate_202207</span></span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref mat mat-class docutils literal notranslate"><span class="pre">handle</span></code></p>
<p>Tube-like sUrface Lagrangian Analysis Resource (TubULAR) class.
Note that TubULAR is fully documented, with docs accessible via:</p>
<blockquote>
<div><p>doc TubULAR</p>
</div></blockquote>
<p><strong>Instantiation</strong>
Set experiment metadata and any custom options……………………..xp=struct(…); opts=struct(…);
Instantiate TubULAR……………………………………………..tubi = TubULAR(xp, opts)</p>
<p><strong>Surface extraction</strong>
Create downsampled volumes to use for iLastik &amp; level sets…………..tubi.prepareIlastik()
Extract the surfaces using level sets on output of iLastik or raw data..tubi.getMeshes()</p>
<p><strong>Parameterization</strong>
Set experiment metadata and any custom options……………………..xp=struct(…); opts=struct(…);
Instantiate TubULAR……………………………………………..tubi = TubULAR(xp, opts)
Define global reference frame (APDV)………………………………tubi.computeAPDVCoords()
Define endcap points and one point for a virtual seam……………….tubi.computeAPDpoints()
Align meshes into global frame……………………………………tubi.alignMeshesAPDV()
Optional: render data on dynamic surfaces………………………….tubi.plotSeriesOnSurfaceTexturePatch()
Compute initial centerlines………………………………………tubi.extractCenterlineSeries()
Temporally average centerlines and fix any inconsistencies…………..tubi.generateCleanCntrlines()
Remove the endcaps………………………………………………tubi.sliceMeshEndcaps()
Clean up the mesh endcaps………………………………………..tubi.cleanCylMeshes()
Cut the meshes along virtual seams………………………………..tubi.generateCurrentCutMesh()
Constrained parameterization of the mesh into (u,v) and (s,phi) frames..tubi.generateCurrentSPCutMesh()
Generate pullback images…………………………………………tubi.generateCurrentPullbacks()</p>
<p><strong>Dynamics</strong>
Initial pass of smoothing embedding over time………………………tubi.smoothDynamicSPhiMeshes()
Create pullbacks of smoothed (s,phi) frames………………………..tubi.generateCurrentPullbacks()
Tile the images in phi (as ‘double-cover’)…………………………tubi.doubleCoverPullbackImages()
Measure any residual material motion in the parameterization…………tubi.measurePIV2d()
Translate pullback information into motion in 3D (embedding space)……tubi.measurePIV3d()</p>
<p><strong>Advanced processing of surface dynamics</strong>
Recommended: smooth the resulting 3D dynamics along material pathlines..tubi.timeAverageVelocities()
Compute material pathlines in 3D………………………………….tubi.measurePullbackPathlines()
Measure rate of strain over the surface at each timepoint……………tubi.measureStrainRate()
Query the rate of strain along pathlines…………………………..tubi.measurePathlineStrainRate()
Measure the integrated strain along pathlines………………………tubi.measurePathlineStrain()</p>
<p><strong>Interpretation and mode decomposition</strong>
Visualize flows…………………………………………………tubi.plotTimeAvgVelocities()
Decompose into Divergence and curl………………………………..tubi.helmotzHodge()
Compute areal rate of change……………………………………..tubi.measureMetricKinematics()
Decompose into Principal Component Analysis………………………..tubi.getPCAoverTime()
Decompose into eigenmodes of the Laplace-Beltrami operator…………..tubi.getLBSoverTime()</p>
<dl class="simple">
<dt>uv<span class="classifier">(conformal map onto unit square)</span></dt><dd><p>Conformally mapping the cylinderCutMesh onto the unit square
in the plane results in the instantaneous uv coordinate system.
Corners of the unit square are taken directly from the cutMesh,
so are liable to include some overall twist.</p>
</dd>
<dt>sphi<span class="classifier">(proper length x rectified azimuthal coordinate)</span></dt><dd><p>quasi-axisymmetric system in which first coordinate is
proper length along surface and second is a rectified azimuthal
coordinate. Rectification means that the surface is rotated as
v-&gt;phi(s), where each s coordinate is offset by a “rotation”
about the surface along a direction that is perpendicular to s
in pullback space. This rectification may be based on surface
positions in R^3 (geometric) or based on intensity motion in
pullback space (material/Lagrangian) inferred through
phasecorrelation of tissue strips around discretized s values.</p>
</dd>
<dt>uvprime<span class="classifier">(conformal map</span></dt><dd><p>[same as uvprime_sm, since uvprime is currently computed via
sphi_sm coordinates]</p>
</dd>
<dt>r/spr/sphir<span class="classifier">(proper length x rectified azimuthal coordinate)</span></dt><dd><p>same as sphi but with aspect ratio relaxed to minimize isoareal
energy cost –&gt; makes triangles more similar in area by scaling
the s axis (longitudinal axis) by a scalar factor.</p>
</dd>
<dt>iLastik’s coordinate systems<span class="classifier">I recommend using cxyz as the axis</span></dt><dd><p>when outputting from iLastik. For our setup, this will mean
that the meshes are mirrored with respect to the lab frame, so
tubi.flipy = true.</p>
</dd>
<dt>PIV measurements fall into two classes:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘piv’: principal surface-Lagrangian-frame PIV (sp_sme or up_sme)</dt><dd><p>–&gt; note that the designation of coordinate system is not
explicitly specified in the filenames:
tubi.dir.mesh/gridCoords_nU0100_nV0100/piv/piv3d, etc</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘piv_uvp_sme’: PIV in coordSys for quasiconformal measurements</dt><dd><p>–&gt; note that these are less Lagrangian than
sp_sme or up_sme, so they are treated as independent from the
principal pipeline in which we measure velocities in a
surface-Lagrangian frame (ie sp_sme or up_sme).</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>imSize        : 2x1 int, size of pullback images to create
xyzlim        : 3x2 float, mesh limits in full resolution pixels, in data space
xyzlim_um     : 3x2 float, mesh limits in lab APDV frame in microns
resolution    : float, resolution of pixels in um
rot           : 3x3 float, APDV rotation matrix
trans         : 3x1 float, APDV translation
a_fixed       : float, aspect ratio for fixed-width pullbacks
phiMethod     : str, ‘3dcurves’ or ‘texture’
flipy         : bool, APDV coord system is mirrored XZ wrt raw data
nV            : int, sampling number along circumferential axis
nU            : int, sampling number along longitudinal axis
uvexten       : str, naming extension with nU and nV like ‘_nU0100_nV0100’
t0            : int, reference timePoint in the experiment
velocityAverage : struct with fields</p>
<blockquote>
<div><dl class="simple">
<dt>vsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 3 float array</span></dt><dd><p>3d velocities at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vfsmM<span class="classifier">(#timePoints-1) x (2*nU*(nV-1)) x 3 float array</span></dt><dd><p>3d velocities at face barycenters in um/dt rs</p>
</dd>
<dt>vnsmM<span class="classifier">(#timePoints-1) x (nX*nY) float array</span></dt><dd><p>normal velocity at PIV evaluation coordinates in um/dt rs</p>
</dd>
<dt>vvsmM<span class="classifier">(#timePoints-1) x (nU*nV) x 3 float array</span></dt><dd><p>3d velocities at (1x resolution) mesh vertices in um/min rs</p>
</dd>
<dt>v2dsmM<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><p>2d velocities at PIV evaluation coordinates in pixels/ min</p>
</dd>
<dt>v2dsmMum<span class="classifier">(#timePoints-1) x (nX*nY) x 2 float array</span></dt><dd><p>2d velocities at PIV evaluation coordinates in scaled pix/min, but
proportional to um/min (scaled by dilation of map)</p>
</dd>
</dl>
</div></blockquote>
<p>QuapSlap allows the user to designate the AP axis, a DV axis, and a
centerline for the segmented object.
To designate APDV coordinate system, use iLastik training on the
timepoint t0 (which is an attribute of tubi). In particular, train on
anterior (A), posterior (P), background (B), and dorsal (D) location
in different iLastik channels. Small blobs of high probability near
the anterior end for A, somewhere along the posterior end for P, and
anywhere along dorsal for D are best. Then the centers of mass of
thresholded contiguous high probability are computed for each to
define the coordinate system. By default, the ilastik results are
read as ch1=A, ch2=P, ch3=B, ch4=D, but anteriorChannel,
posteriorChannel, and dorsalChannel specify the iLastik
training channel that is used for each specification.
Name the h5 file output from iLastik as
…_Probabilities_APDVcoords.h5
For example, dorsal for the gut was chosen at the fused site where
additional 48YGAL4-expressing muscle-like cells form a seam.
Posterior is at the rear of the yolk, where the endoderm closes, for
apical surface training. Anterior is at the junction of the midgut
with the foregut.
Separately, define the AP points for centerline extraction. For most gut
data, the posterior point is different in centerline than it is for AP
centerline specification, so we use a different ILP to train for A and P
for all timepoints of dynamic data.</p>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV">
<span class="sig-name descname"><span class="pre">APDV</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'resolution',</span> <span class="pre">[],</span> <span class="pre">\n'rot',</span> <span class="pre">[],</span> <span class="pre">\n'trans',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV" title="Permalink to this definition">#</a></dt>
<dd><p>translation vector to transform data into APDV frame (rot*v+trans)*resolution</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV2dxyz">
<span class="sig-name descname"><span class="pre">APDV2dxyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV2dxyz" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d vectors from APDV coord sys to XYZ data space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV2xyz">
<span class="sig-name descname"><span class="pre">APDV2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.APDV2xyz" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d coords from APDV coord sys to XYZ data space</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.XY2uv">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">XY2uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">XY</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.XY2uv" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Map pixel positions (1, sizeImX) and (1, sizeImY) to
(0, umax) and (0, vmax) of pullback space if singleCover,
or y coords are mapped to (-0.5, 1.5)*vmax if doubleCover</p>
</div></blockquote>
<p>NOTE THAT MAP IS
[xesz, yesz] = [size(im, 1), size(im, 2)]
uv(:, 1) = umax * (XY(:, 1) - 1) / xesz ;
uv(:, 2) = vmax * 2.0 * (XY(:, 2) - 1) / yesz - 0.5 ;</p>
<p>NOTE THAT INVERSE MAP IS
x–&gt; (xy(:, 1) * (Xsz-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (Ysz-1)) / (2*vmax) + 1 + (Ysz-1)*0.25 ;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">2</span> <span class="pre">ints</span> <span class="pre">for</span> <span class="pre">size</span></code></span>) – image in which pixel coordinates are defined or dimensions
of the image (pullback image in pixels)</p></li>
<li><p><strong>XY</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Qx2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – pixel coordinates to convert to pullback space</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uv</strong> – pullback coordinates of input pixel coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Qx2 numeric array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.a_fixed">
<span class="sig-name descname"><span class="pre">a_fixed</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.a_fixed" title="Permalink to this definition">#</a></dt>
<dd><p>aspect ratio for fixed geometry pullback meshes</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.adjustIV">
<span class="sig-name descname"><span class="pre">adjustIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">IV</span></em>, <em class="sig-param"><span class="pre">adjustlow</span></em>, <em class="sig-param"><span class="pre">adjusthigh</span></em>, <em class="sig-param"><span class="pre">forceValues</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.adjustIV" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>IV</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">3D</span> <span class="pre">numeric</span> <span class="pre">(optional,</span> <span class="pre">loads</span> <span class="pre">currentData</span> <span class="pre">if</span> <span class="pre">empty)</span></code></span>) – data to adjust</p></li>
<li><p><strong>adjustlow</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">numeric</span> <span class="pre">or</span> <span class="pre">#channels</span> <span class="pre">x</span> <span class="pre">1</span> <span class="pre">numeric</span></code></span>) – minimum intensity or percent intensity to adjust data</p></li>
<li><p><strong>adjusthigh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">numeric</span> <span class="pre">or</span> <span class="pre">#channels</span> <span class="pre">x</span> <span class="pre">1</span> <span class="pre">numeric</span></code></span>) – maximum intensity or percent intensity to adjust data</p></li>
<li><p><strong>forceValues</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">enforce</span> <span class="pre">the</span> <span class="pre">adjustlow/high</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">intensity</span></code></span>) – </p></li>
<li><p><strong>values</strong> – </p></li>
<li><p><strong>percentile</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">not</span></code></span>) – </p></li>
<li><p><strong>100.</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">even</span> <span class="pre">if</span> <span class="pre">&lt;</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.apdvOptions">
<span class="sig-name descname"><span class="pre">apdvOptions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.apdvOptions" title="Permalink to this definition">#</a></dt>
<dd><p>Options for computing the APDV frame</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.cleanCntrlines">
<span class="sig-name descname"><span class="pre">cleanCntrlines</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.cleanCntrlines" title="Permalink to this definition">#</a></dt>
<dd><p>centerlines in embedding space, no temporal filtering</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.clearTime">
<span class="sig-name descname"><span class="pre">clearTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.clearTime" title="Permalink to this definition">#</a></dt>
<dd><p>clear current timepoint’s data for tubi instance</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.clipXY">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">clipXY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">xx</span></em>, <em class="sig-param"><span class="pre">yy</span></em>, <em class="sig-param"><span class="pre">Lx</span></em>, <em class="sig-param"><span class="pre">Ly</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.clipXY" title="Permalink to this definition">#</a></dt>
<dd><p>Clip x at (1, Lx) and clip Y as periodic (1=Ly, Ly=1), for
image that is periodic in Y. Consider Y in [1, Ly]. If the
pullback is a doubleCover, Ly = 2*mesh width in pixels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xx</strong> – </p></li>
<li><p><strong>yy</strong> – </p></li>
<li><p><strong>Lx</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – number of pixels along x dimension</p></li>
<li><p><strong>Ly</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – number of pixels along y dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>[xx, yy]</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>x and y coordinates clipped to [1, Lx] and [1, Ly]</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.coordSystemDemo">
<span class="sig-name descname"><span class="pre">coordSystemDemo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.coordSystemDemo" title="Permalink to this definition">#</a></dt>
<dd><p>Image for publication/presentation on method &amp; coordinate system
Create coordinate system charts visualization using smoothed meshes
options : struct with fields</p>
<blockquote>
<div><p>style : ‘curves’ or ‘surface’</p>
</div></blockquote>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentData">
<span class="sig-name descname"><span class="pre">currentData</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'IV',</span> <span class="pre">[],</span> <span class="pre">\n'adjustlow',</span> <span class="pre">0,</span> <span class="pre">\n'adjusthigh',</span> <span class="pre">0</span> <span class="pre">)"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentData" title="Permalink to this definition">#</a></dt>
<dd><p>image intensity data in 3d and scaling</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentMesh">
<span class="sig-name descname"><span class="pre">currentMesh</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'rawMesh',</span> <span class="pre">[],</span> <span class="pre">\n'alignedMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cylinderMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cylinderMeshClean',</span> <span class="pre">[],</span> <span class="pre">\n'cutMesh',</span> <span class="pre">[],</span> <span class="pre">\n'cutPath',</span> <span class="pre">[],</span> <span class="pre">\n'uvcutMesh',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMesh',</span> <span class="pre">[],</span>         <span class="pre">%</span> <span class="pre">rectilinear</span> <span class="pre">cutMesh</span> <span class="pre">in</span> <span class="pre">(s,phi)</span> <span class="pre">'surface</span> <span class="pre">Lagrangian'</span> <span class="pre">parameterization\n'spcutMeshSm',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMeshSmRS',</span> <span class="pre">[],</span> <span class="pre">\n'spcutMeshSmRSC',</span> <span class="pre">[],</span> <span class="pre">\n'ricciMesh',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentMesh" title="Permalink to this definition">#</a></dt>
<dd><p>ricci flow result pullback mesh, topological annulus</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentStrain">
<span class="sig-name descname"><span class="pre">currentStrain</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'pathline',</span> <span class="pre">\nstruct('t0Pathlines',</span> <span class="pre">[],</span> <span class="pre">\n'strain',</span> <span class="pre">[],</span> <span class="pre">\n'beltrami',</span> <span class="pre">[]))"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentStrain" title="Permalink to this definition">#</a></dt>
<dd><p>beltrami coefficient for pathlines</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentTime">
<span class="sig-name descname"><span class="pre">currentTime</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.currentTime" title="Permalink to this definition">#</a></dt>
<dd><p>int, the timepoint of the current frame under examination (this can be set with setTime and changes during many method calls)</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dXY2duv">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">dXY2duv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">dXY</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dXY2duv" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>XY2uv(im, XY, doubleCovered, umax, vmax)</dt><dd><p>Map difference in pixel positions defined on
(1, sizeImX) and (1, sizeImY) to
(0, umax) and (0, vmax) of pullback space if singleCover,
or y coords are mapped to (-0.5, 1.5)*vmax if doubleCover</p>
</dd>
</dl>
<p>NOTE THAT FULL COORDINATE MAP IS
[xesz, yesz] = [size(im, 1), size(im, 2)]
uv(:, 1) = umax * (XY(:, 1) - 1) / xesz ;
uv(:, 2) = vmax * 2.0 * (XY(:, 2) - 1) / yesz - 0.5 ;</p>
<p>NOTE THAT INVERSE MAP IS
x–&gt; (xy(:, 1) * (Xsz-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (Ysz-1)) / (2*vmax) + 1 + (Ysz-1)*0.25 ;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">2</span> <span class="pre">ints</span> <span class="pre">for</span> <span class="pre">size</span></code></span>) – image in which pixel coordinates are defined or dimensions
of the image (pullback image in pixels)</p></li>
<li><p><strong>dXY</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Qx2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – difference in pixel coordinates as vector, to convert to
pullback space</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>uv</strong> – pullback coordinates of input pixel coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Qx2 numeric array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.data">
<span class="sig-name descname"><span class="pre">data</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'adjustlow',</span> <span class="pre">0,</span> <span class="pre">\n'adjusthigh',</span> <span class="pre">0,</span> <span class="pre">\n'axisOrder',</span> <span class="pre">[1</span> <span class="pre">2</span> <span class="pre">3],</span> <span class="pre">\n'ilastikOutputAxisOrder',</span> <span class="pre">'cxyz')"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.data" title="Permalink to this definition">#</a></dt>
<dd><p>options for scaling and transposing image intensity data</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dir">
<span class="sig-name descname"><span class="pre">dir</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dir" title="Permalink to this definition">#</a></dt>
<dd><p>str, directory where QuapSlap data lives</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.doubleCoverPullbackImages">
<span class="sig-name descname"><span class="pre">doubleCoverPullbackImages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.doubleCoverPullbackImages" title="Permalink to this definition">#</a></dt>
<dd><p>options : struct with fields
coordsys : (‘sp’, ‘uv’, ‘up’)</p>
<blockquote>
<div><p>coordinate system to make double cover</p>
</div></blockquote>
<dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>whether to overwrite current images on disk</p>
</dd>
<dt>histeq<span class="classifier">bool, default=true</span></dt><dd><p>perform histogram equilization during pullback
extension</p>
</dd>
<dt>ntiles<span class="classifier">int, default=50</span></dt><dd><p>The number of bins in each dimension for histogram equilization for a
square original image. That is, the extended image will have (a_fixed *
ntiles, 2 * ntiles) bins in (x,y).</p>
</dd>
<dt>a_fixed<span class="classifier">float, default=tubi.a_fixed</span></dt><dd><p>The aspect ratio of the pullback image: Lx / Ly</p>
</dd>
</dl>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.doubleToSingleCover">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">doubleToSingleCover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">XY</span></em>, <em class="sig-param"><span class="pre">Ly</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.doubleToSingleCover" title="Permalink to this definition">#</a></dt>
<dd><p>detect if XY is passed as a pair of grids</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dvAverageNematic">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">dvAverageNematic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">magnitude</span></em>, <em class="sig-param"><span class="pre">theta</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dvAverageNematic" title="Permalink to this definition">#</a></dt>
<dd><p>[mag_ap, theta_ap] = DVAVERAGENEMATIC(magnitude, theta)
Given a nematic field defined on a rectilinear grid, with
Q(i,j) being in the ith ap position and jth dv position,
average the nematic field over the dv positions (dimension 2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnitude</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">nU</span> <span class="pre">x</span> <span class="pre">nV</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – magnitude of nematic field in 2D rectilinear grid</p></li>
<li><p><strong>theta</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">nU</span> <span class="pre">x</span> <span class="pre">nV</span> <span class="pre">float</span> <span class="pre">array,</span> <span class="pre">with</span> <span class="pre">values</span> <span class="pre">as</span> <span class="pre">angles</span> <span class="pre">in</span> <span class="pre">radians</span></code></span>) – angle (mod pi) of nematic field in 2D rectilinear grid</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mag_ap</strong> (<em>nU x 1 float array</em>) – average magnitude of nematic field along the ap dimension</p></li>
<li><p><strong>theta_ap</strong> (<em>nU x 1 float array</em>) – average angle (mod pi) of nematic field along the ap
dimension</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dx2APDV">
<span class="sig-name descname"><span class="pre">dx2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">da</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dx2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>dars = dx2APDV(tubi, da)
Transform 3d difference vector from XYZ data space to APDV
coord sys</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dynamic">
<span class="sig-name descname"><span class="pre">dynamic</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.dynamic" title="Permalink to this definition">#</a></dt>
<dd><p>expMeta : struct with fields
fileMeta : struct with fields</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.endcapOptions">
<span class="sig-name descname"><span class="pre">endcapOptions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.endcapOptions" title="Permalink to this definition">#</a></dt>
<dd><p>the full map from embedding to pullback being [M’=(Phi)o()o()].
This string specifier must be ‘3dcurves’ (geometric phi stabilization)
or ‘texture’ (optical flow phi stabilization)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fileBase">
<span class="sig-name descname"><span class="pre">fileBase</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fileBase" title="Permalink to this definition">#</a></dt>
<dd><p>fileNames to be populated by timestamp (’…%06dmat’)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fileName">
<span class="sig-name descname"><span class="pre">fileName</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fileName" title="Permalink to this definition">#</a></dt>
<dd><p>fileName struct with fields such as rot, trans, etc where measurements/parameters are stored on disk</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.flipy">
<span class="sig-name descname"><span class="pre">flipy</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.flipy" title="Permalink to this definition">#</a></dt>
<dd><p>whether data is mirror image of lab frame coordinates</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fullFileBase">
<span class="sig-name descname"><span class="pre">fullFileBase</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.fullFileBase" title="Permalink to this definition">#</a></dt>
<dd><p>full path of filenames (like fullfile(tubi.dir.X, tubi.fileBase.X))</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getAPpointsSm">
<span class="sig-name descname"><span class="pre">getAPpointsSm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getAPpointsSm" title="Permalink to this definition">#</a></dt>
<dd><p>Load the anterior and posterior ‘centers of mass’ ie the
endpoints of the object’s centerline</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentPathlineStrain">
<span class="sig-name descname"><span class="pre">getCurrentPathlineStrain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0Pathlines</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentPathlineStrain" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">current</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>t0Pathlines</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">or</span> <span class="pre">empty</span></code></span>) – reference timepoint. If empty, set to tubi.t0set()</p></li>
<li><p><strong>varargin</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">strings</span> <span class="pre">('strain',</span> <span class="pre">'beltrami')</span></code></span>) – which strain measures to load from disk and attribute to
self</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>strain</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tubi.currentStrain.pathline</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation2D">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation2D" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pullback space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation2DCorrected">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation2DCorrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation2DCorrected" title="Permalink to this definition">#</a></dt>
<dd><p>Decide on coordinate system for corrected pullback binary</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation3D">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation3D" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pushforward space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation3DCorrected">
<span class="sig-name descname"><span class="pre">getCurrentSegmentation3DCorrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getCurrentSegmentation3DCorrected" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain the cell segmentation in 3D pullback space</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getPIV">
<span class="sig-name descname"><span class="pre">getPIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getPIV" title="Permalink to this definition">#</a></dt>
<dd><p>Load PIV results and store in tubi.piv if not already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getPullbackPathlines">
<span class="sig-name descname"><span class="pre">getPullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getPullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><p>Discern if we must load pathlines or if already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getRadii">
<span class="sig-name descname"><span class="pre">getRadii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getRadii" title="Permalink to this definition">#</a></dt>
<dd><p>Load radii from disk in specified coordinate system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>coordSys: str specifier for how to return radii</dt><dd><p>’spcutMeshSmRSC’ –&gt; return nU x (nV-1) array for radii
of vertices in spcutMeshSmRSC embedding
&lt;add other options here&gt;</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getRotTrans">
<span class="sig-name descname"><span class="pre">getRotTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getRotTrans" title="Permalink to this definition">#</a></dt>
<dd><p>Load the translation to put anterior to origin and AP axis
along x axis</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocityAverage">
<span class="sig-name descname"><span class="pre">getVelocityAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocityRaw">
<span class="sig-name descname"><span class="pre">getVelocityRaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocitySimpleAverage">
<span class="sig-name descname"><span class="pre">getVelocitySimpleAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getVelocitySimpleAverage" title="Permalink to this definition">#</a></dt>
<dd><p>todo: check if all varargin are already loaded</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getXYZLims">
<span class="sig-name descname"><span class="pre">getXYZLims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.getXYZLims" title="Permalink to this definition">#</a></dt>
<dd><p>[raw, pix, um, um_buff] = GETXYZLIMS(tubi)
Grab each xyzlim from self, otherwise load from disk
full resolution pix</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.imSize">
<span class="sig-name descname"><span class="pre">imSize</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.imSize" title="Permalink to this definition">#</a></dt>
<dd><p>size of pullback images to create (default is [a_ratio * 1000, 1000])</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.invertRotation">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">invertRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rot</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.invertRotation" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain rotation matrix that undoes the APDV rotation</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadPIV">
<span class="sig-name descname"><span class="pre">loadPIV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadPIV" title="Permalink to this definition">#</a></dt>
<dd><p>Load PIV results from disk and store in tubi.piv</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocityAverage">
<span class="sig-name descname"><span class="pre">loadVelocityAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>Retreive the Velocity on each vertex/face barycenter of the
(s,phi) meshes.
NOTE: that these are nearly Lagrangian for most applications,
but not perfectly Lagrangian. See also:
tubi.getPullbackPathlines(t0), which corrects for any
residual motion in the pullback plane.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocityRaw">
<span class="sig-name descname"><span class="pre">loadVelocityRaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>Load and pack into struct</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocitySimpleAverage">
<span class="sig-name descname"><span class="pre">loadVelocitySimpleAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.loadVelocitySimpleAverage" title="Permalink to this definition">#</a></dt>
<dd><p>Load and pack into struct</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.measureRMSvelocityOverTime">
<span class="sig-name descname"><span class="pre">measureRMSvelocityOverTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.measureRMSvelocityOverTime" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – weights : weights to attribute to each face in mesh
coordSys : str specifier (default==’sp’)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vrms</strong> (<em>#tps x 1 float array</em>) – rms velocity over time</p></li>
<li><p><strong>timestamps</strong> (<em>#tps x 1 float array</em>) – timestamps associated with each entry</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.nU">
<span class="sig-name descname"><span class="pre">nU</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.nU" title="Permalink to this definition">#</a></dt>
<dd><p>sampling number along longitudinal axis</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.nV">
<span class="sig-name descname"><span class="pre">nV</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.nV" title="Permalink to this definition">#</a></dt>
<dd><p>sampling number along circumferential axis</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.normalShift">
<span class="sig-name descname"><span class="pre">normalShift</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0'</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.normalShift" title="Permalink to this definition">#</a></dt>
<dd><p>shift to apply to meshes in pixel space along normal direction</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.phiMethod">
<span class="sig-name descname"><span class="pre">phiMethod</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'3dcurves'"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.phiMethod" title="Permalink to this definition">#</a></dt>
<dd><p>method for determining Phi map in pullback mesh creation, with</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.piv">
<span class="sig-name descname"><span class="pre">piv</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>             <span class="pre">'imCoords',</span> <span class="pre">'sp_sme',</span> <span class="pre">\n'Lx',</span> <span class="pre">[],</span> <span class="pre">\n'Ly',</span> <span class="pre">[],</span> <span class="pre">\n'raw',</span> <span class="pre">struct(),</span> <span class="pre">\n'smoothed',</span> <span class="pre">struct(),</span> <span class="pre">\n'smoothing_sigma',</span> <span class="pre">1</span> <span class="pre">)"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.piv" title="Permalink to this definition">#</a></dt>
<dd><p>sigma of gaussian smoothing on PIV, in units of PIV sampling grid pixels</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.plotPathlineBeltramiKymograph">
<span class="sig-name descname"><span class="pre">plotPathlineBeltramiKymograph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0Pathlines</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.plotPathlineBeltramiKymograph" title="Permalink to this definition">#</a></dt>
<dd><p>Example usage for 2021 gut paper:
options = struct(‘ylim’, [0, 2] )
tubi.plotPathlineBeltramiKymograph([], options)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.plotting">
<span class="sig-name descname"><span class="pre">plotting</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'preview',</span> <span class="pre">false,</span> <span class="pre">\n'save_ims',</span> <span class="pre">true,</span> <span class="pre">\n'xyzlim_um_buff',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_raw',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_pix',</span> <span class="pre">[],</span> <span class="pre">\n'xyzlim_um',</span> <span class="pre">[],</span> <span class="pre">\n'colors',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.plotting" title="Permalink to this definition">#</a></dt>
<dd><p>adist : distance around anterior point A which is removed from tubular mesh (sliced off)
pdist : distance around anterior point P which is removed from tubular mesh (sliced off)
tref : reference time used to define th point on the endcap</p>
<blockquote>
<div><p>at which we cut the cylinder mesh into a cylinderCutMesh (a topological disk/square).
This “dorsal” point for other timepoints are identified by pointmatching.</p>
</div></blockquote>
<p>Additional fields allowed :</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.quarterIndicesDV">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">quarterIndicesDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nV</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.quarterIndicesDV" title="Permalink to this definition">#</a></dt>
<dd><p>[dorsal, ventral, left, right] = quarterIndicesDV(nV)
indices for each quarter of a DV section in grid coordinates</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.samplePullbackPathlines">
<span class="sig-name descname"><span class="pre">samplePullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">XY0</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.samplePullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><p>[p2d, p3d] = samplePullbackPathlines(tubi, XY0, options)
start at XY0, folow flow using barycentric coordinates of PIV
pullback pathlines. This is the same as advecting along a
fixed Langrangian coordinate.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.setDataLimits">
<span class="sig-name descname"><span class="pre">setDataLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">adjustlow_pctile</span></em>, <em class="sig-param"><span class="pre">adjusthigh_pctile</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.setDataLimits" title="Permalink to this definition">#</a></dt>
<dd><p>Use timepoint (tp) to obtain hard values for intensity limits
so that data is rescaled to fixed limits instead of
percentile. This is useful to avoid flickering of overall
intensity in data in which a few voxels vary a lot in
intensity.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.setTime">
<span class="sig-name descname"><span class="pre">setTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.setTime" title="Permalink to this definition">#</a></dt>
<dd><p>Set the current time of the dataset and clear current data
which was associated with the previously considered time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tt</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">or</span> <span class="pre">float</span></code></span>) – timePoint to set to be current, from available times in
tubi.xp.fileMeta.timePoints</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.smoothing">
<span class="sig-name descname"><span class="pre">smoothing</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'lambda',</span> <span class="pre">0.00,</span> <span class="pre">\n'lambda_mesh',</span> <span class="pre">0.00,</span> <span class="pre">\n'nmodes',</span> <span class="pre">7,</span> <span class="pre">\n'zwidth',</span> <span class="pre">1)"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.smoothing" title="Permalink to this definition">#</a></dt>
<dd><p>half-width of tripulse filter applied along zeta/z/s/u direction in pullback space, in units of du/dz/ds/dzeta</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.spaceUnits">
<span class="sig-name descname"><span class="pre">spaceUnits</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'$\\mu$m'"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.spaceUnits" title="Permalink to this definition">#</a></dt>
<dd><p>units of the embedding space (ex ‘$mu$m’)</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.ssfactor">
<span class="sig-name descname"><span class="pre">ssfactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.ssfactor" title="Permalink to this definition">#</a></dt>
<dd><p>subsampling factor for probabilities</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.t0">
<span class="sig-name descname"><span class="pre">t0</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.t0" title="Permalink to this definition">#</a></dt>
<dd><p>reference time in the experiment</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.t0set">
<span class="sig-name descname"><span class="pre">t0set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">t0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.t0set" title="Permalink to this definition">#</a></dt>
<dd><p>t0set(tubi, t0) Set time offset from file or manually</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.timeInterval">
<span class="sig-name descname"><span class="pre">timeInterval</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.timeInterval" title="Permalink to this definition">#</a></dt>
<dd><p>increment in time between timepoints with</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.timeUnits">
<span class="sig-name descname"><span class="pre">timeUnits</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"'min'"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.timeUnits" title="Permalink to this definition">#</a></dt>
<dd><p>indices differing by 1. For example, if
timePoints are [0,1,2,4] and these are
[1,1,2] minutes apart, then timeInterval
is 1.</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.trueTime">
<span class="sig-name descname"><span class="pre">trueTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">div60</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.trueTime" title="Permalink to this definition">#</a></dt>
<dd><p>Convert timepoint into timestamp in physical units (like
minutes, hours, etc) relative to t0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – timestamp to convert to “true” time relative to t0 in real
units</p></li>
<li><p><strong>div60</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – Convert to a larger time unit than tubi.timeUnits, so if
tubi.timeUnits is sec(onds), convert to minutes. Or, if
tubi.timeUnits is min(utes), convert to hours.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>tpTrue</strong> (<em>float</em>) – the timestamp relative to t0 in true units (tubi.timeUnits)</p></li>
<li><p><strong>timestr</strong> (<em>char</em>) – string with timestamp relative to t0 and its units</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uv2APDV">
<span class="sig-name descname"><span class="pre">uv2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">uv</span></em>, <em class="sig-param"><span class="pre">coordSys</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uv2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>Convert (u,v) pullback coordinates to xyz coordinates in the
APDV frame (rotated and scaled frame aligned with AP axis
along x and DV axis along z)</p>
</dd></dl>
<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uv2XY">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">uv2XY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">im</span></em>, <em class="sig-param"><span class="pre">uv</span></em>, <em class="sig-param"><span class="pre">doubleCovered</span></em>, <em class="sig-param"><span class="pre">umax</span></em>, <em class="sig-param"><span class="pre">vmax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uv2XY" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>XY = uv2XY(im, uv, doubleCovered, umax, vmax)</dt><dd><p>Map from pullback uv u=(0,1), v=(0,1) to pixel XY</p>
</dd>
</dl>
<p>x–&gt; (xy(:, 1) * (size(im, 2)-1)) / (1*umax) + 1 , …
y–&gt; (xy(:, 2) * (size(im, 1)-1)) / (2*vmax) + 0.75 + (size(im,1)-1)*0.25</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NxM</span> <span class="pre">numeric</span> <span class="pre">array</span> <span class="pre">or</span> <span class="pre">length(2)</span> <span class="pre">int</span> <span class="pre">array</span></code></span>) – 2D image into whose pixel space to map or size(im)</p></li>
<li><p><strong>uv</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Q*2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – mesh coordinates to convert to pullback pixel space (XY)</p></li>
<li><p><strong>doubleCovered</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – the image is a double cover of the pullback (extended/tiled
so that the “top” half repeats below the bottom and the
“bottom” half repeats above the top. That is,
consider im to be a double cover in Y (periodic in Y and
covers pullback space twice (-0.5 * Ly, 1.5 * Ly)</p></li>
<li><p><strong>umax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in u direction (X)</p></li>
<li><p><strong>vmax</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – extent of pullback mesh coordinates in v direction (Y)
before double covering/tiling</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>XY</strong> – positions of uv coordinates in pullback pixel space</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x 2 float array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uvexten">
<span class="sig-name descname"><span class="pre">uvexten</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.uvexten" title="Permalink to this definition">#</a></dt>
<dd><p>naming extension with nU and nV like ‘_nU0100_nV0100’</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.velocityAverage">
<span class="sig-name descname"><span class="pre">velocityAverage</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'v3d',</span> <span class="pre">[],</span> <span class="pre">\n'v2d',</span> <span class="pre">[],</span> <span class="pre">\n'v2dum',</span> <span class="pre">[],</span> <span class="pre">\n'vn',</span> <span class="pre">[],</span> <span class="pre">\n'vf',</span> <span class="pre">[],</span> <span class="pre">\n'vv',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.velocityAverage" title="Permalink to this definition">#</a></dt>
<dd><p>velocity field on vertices after Lagrangian avg</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.velocityRaw">
<span class="sig-name descname"><span class="pre">velocityRaw</span></span><em class="property"> <span class="pre">=</span> <span class="pre">"struct(</span>            <span class="pre">'v3d',</span> <span class="pre">[],</span> <span class="pre">\n'v2d',</span> <span class="pre">[],</span> <span class="pre">\n'v2dum',</span> <span class="pre">[],</span> <span class="pre">\n'vn',</span> <span class="pre">[],</span> <span class="pre">\n'vf',</span> <span class="pre">[],</span> <span class="pre">\n'vv',</span> <span class="pre">[])"</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.velocityRaw" title="Permalink to this definition">#</a></dt>
<dd><p>velocity field on vertices, no temporal filtering</p>
</dd></dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.xp">
<span class="sig-name descname"><span class="pre">xp</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.xp" title="Permalink to this definition">#</a></dt>
<dd><p>struct with fields or ImSAnE experiment class instance</p>
</dd></dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.xyz2APDV">
<span class="sig-name descname"><span class="pre">xyz2APDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.Tubular_local_keep_these_changes_incorporate_202207.xyz2APDV" title="Permalink to this definition">#</a></dt>
<dd><p>ars = xyz2APDV(tubi, a)
Transform 3d coords from XYZ data space to APDV coord sys</p>
</dd></dl>
</dd></dl>
<dl class="mat script">
<dt class="sig sig-object mat" id="@TubULAR.alignMaskedDataAPDV">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">alignMaskedDataAPDV</span></span><a class="headerlink" href="#@TubULAR.alignMaskedDataAPDV" title="Permalink to this definition">#</a></dt>
<dd><p>function alignMaskedDataAPDV(QS)
Given training on midgut cells and spurious (amnioserosa) cells as
h5 files in dir16bit/stabilized_h5s/, mask the original data and save 3d
volumes.
Note: if QS.plotting.preview == True, displays intermediate results</p>
<p>THIS IS AT PRESENT UNFINISHED 2020</p>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.alignMeshesAPDV">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">alignMeshesAPDV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.alignMeshesAPDV" title="Permalink to this definition">#</a></dt>
<dd><p>ALIGNMESHESAPDV(opts)
Uses anterior, posterior, and dorsal training in ilastik h5 output to
align meshes along APDV coordinate system with global rotation matrix
and translation vector. Extracted pts from the
segmented training is loaded/saved in h5 file opts.rawapdvname (usually
“apdv_pts_from_training.h5”).
Smoothed pts from the segmented training –&gt; opts.rawapdvname
Smoothed rotated scaled pts              –&gt; opts.outapdvname
Note that the global rotation matrix for the QuapSlap instance is defined
previously in ptputeAPdpts()</p>
<p>This is a function similar to the align_meshes_APDV.m script</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>overwrite     : bool
overwrite_ims : bool
smwindow      : float or int</p>
<blockquote>
<div><p>number of timepoints over which we smooth</p>
</div></blockquote>
<dl class="simple">
<dt>normal_step<span class="classifier">float</span></dt><dd><p>how far inside to push start/endpoints for centerline extraction
(should be about 1 pixel to ensure centerlines can be found with
some downsampling)</p>
</dd>
<dt>forceEndpointsInside<span class="classifier">bool</span></dt><dd><p>push the start/ednpoints for centerline extraction further inside
the mesh even if they are already a little bit inside the mesh</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>xyzlim_raw</em> – xyzlimits of raw meshes in units of full resolution pixels (ie not
downsampled)</p></li>
<li><p><em>xyzlim</em> – xyzlimits of rotated and translated meshes in units of full resolution
pixels (ie not downsampled)</p></li>
<li><p><em>xyzlim_um</em> – xyz limits of rotated and translated meshes in microns</p></li>
<li><p><em>xyzlim_um_buff</em> – xyz limits of rotated and translated meshes in microns, with padding of
QS.normalShift * resolution in every dimension</p></li>
<li><p><em>OUTPUTS</em></p></li>
<li><p><em>——-</em></p></li>
<li><p><em>xyzlim.txt</em> – xyzlimits of raw meshes in units of full resolution pixels (ie not
downsampled)</p></li>
<li><p><em>xyzlim_APDV.txt</em> – xyzlimits of rotated and translated meshes in units of full resolution
pixels (ie not downsampled)</p></li>
<li><p><em>xyzlim_APDV_um.txt</em> – xyz limits of rotated and translated meshes in microns</p></li>
<li><p><em>rotation_APDV.txt</em> – rotation matrix to align mesh to APDV frame, saved to
fullfile(meshDir, ‘rotation_APDV.txt’) ;</p></li>
<li><p><em>translation_APDV.txt</em> – translation vector to align mesh to APDV frame, saved to
fullfile(meshDir, ‘translation_APDV.txt’)</p></li>
<li><p><em>xyzlim.txt</em> – raw bounding box in original frame (not rotated), in full res pixels.
Saved to fullfile(meshDir, ‘xyzlim.txt’)</p></li>
<li><p><em>xyzlim_APDV.txt</em> – bounding box in rotated frame, in full resolution pixels. Saved to
fullfile(meshDir, ‘xyzlim_APDV.txt’)</p></li>
<li><p><em>xyzlim_APDV_um.txt</em> – bounding box in rotated frame, in microns. Saved to
fullfile(meshDir, ‘xyzlim_APDV_um.txt’)</p></li>
<li><p><em>apdv_pts_rs.h5 (outapdvname)</em> – Centers of mass for A, P, and D in microns in rotated, scaled APDV
coord system. Note that this coord system is mirrored if flipy==true.
Also contains raw apt,ppt,dpt in subsampled pixels.
Saved to fullfile(meshDir, ‘centerline/apdv_pts_rs.h5’)</p></li>
<li><p><em>startendpt.h5</em> – Starting and ending points
Saved to fullfile(meshDir, ‘centerline/startendpt_rs.h5’) ;</p></li>
<li><p><strong>forceEndpointInside</strong> (<em>bool</em>) – push the endpoints for crude (fast marching) centerline extraction
further inside the mesh by pushing along vertex normals by normal_step</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.cleanCylMeshes">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">cleanCylMeshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">cleanCylOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.cleanCylMeshes" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.cleanFastMarchingCenterlines">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">cleanFastMarchingCenterlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">idOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.cleanFastMarchingCenterlines" title="Permalink to this definition">#</a></dt>
<dd><p>cntrlines = cleanFastMarchingCenterlines(QS, idOptions)
Identify anomalous centerlines in a time series, fix them and save.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>idOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul>
<li><dl class="simple">
<dt>ssr_thres<span class="classifier">float</span></dt><dd><p>threshold sum of squared residuals between adjacent timepoint
centerlines to consider the later timepoint centerline to be
anomalous &amp; require cleaning</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite the centerlines on disk</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>QS.cleanCntrlines</strong> (<em>length(timePoints) x 1 cell</em>) – populated with cntrlines in XYZ coords (data space, pixels)</p></li>
<li><p><em>QS.fileName.cleanCntrlines</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeAPDVCoords">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeAPDVCoords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeAPDVCoords" title="Permalink to this definition">#</a></dt>
<dd><p>[acom,pcom,dcom, rot,trans] = computeAPDVCoords(tubi, opts)
Compute the APDV coordinate system, defined WRT the data coordSys by a
rotation, translation, and resolution. This is done by identifying a
dorsal point, so that z dim in APDV points from the AP axis to dorsal
along the shortest linesegment emanating from the AP axis to the dorsal
point.
By default, use_iLastik==false, so we just look at the reference time’s
mesh in 3D, pick out the data volume axis closest to the long axis of the
mesh, and point the dorsal vector perpendicular to that. For ex, if we
have an embryo surface elongated along the first dimension of our data
volume, then the first dimension becomes our AP axis, and the third
dimension is the DV axis.</p>
<p>If acom,pcom,dcom are all inferred from iLastik training, the default
channels used to extract the blobs of high probability marking A,P, and a
point D that is dorsal to the line connecting AP are:</p>
<blockquote>
<div><p>A : 1
P : 2
D : 4</p>
</div></blockquote>
<p>This would leave channel 3 (and 5+) to be a background channel in the
iLastik training.</p>
<p>Chirality: note that the probabilties field is assumed to be meshlike so
the first two axis are swapped within com_region().</p>
<p>Todo: back-save acom_for_rot and pcom_for_rot for datasets already
processed, inferred from rot and trans</p>
<p>Note that axisOrder is applying upon invoking getCurrentData()</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeAPDpoints">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeAPDpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeAPDpoints" title="Permalink to this definition">#</a></dt>
<dd><p>[apts_sm, ppts_sm, dpt] = COMPUTEAPDPOINTS(opts)
Compute the anterior, posterior, and dorsal points either from:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Clicking on the points on the mesh from t=t0</p></li>
<li><p>moments of inertia of the mesh surface, identifying the endpoints
near the long axis of the object at t=t0. (autoAP = true)</p></li>
<li><p>iLastik training for CENTERLINE computation.  (use_iLastik=true)
Note that these are allowed to be different than the
APD points for ALIGNMENT computation.
For example, the posterior point
might be a point which does NOT form an AP axis  with the
anteriormost point, as in the illustration of the midgut below:</p></li>
<li><p>Directly supplying a custom set of anterior and posterior points
for each time point</p>
<blockquote>
<div><blockquote>
<div><p>Posterior pt for centerline</p>
</div></blockquote>
<p>_x_         Dorsal pt</p>
</div></blockquote>
<p>/  /     ___x_</p>
</li>
</ol>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>/  /    /      </p>
</div></blockquote>
<p>/  /____/          Anterior pt for both centerline and for defining APDV axes</p>
</div></blockquote>
<div class="line-block">
<div class="line">x P for APDV    | x
________________/</div>
</div>
<p>(ventral here, unlabeled)</p>
</div></blockquote>
</div></blockquote>
<p>The default behavior is to use iLastik training if found, unless
opts.use_iLastik is set to false. If use_iLastik is false or no iLastik
output is found, the default is to have the user click on the points.
If opts.autoAP == true, then we automatically find A and P positions by
simply point matching from line intersections onto the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul class="simple">
<li><p>use_iLastik : default=true if training h5s are present on disk</p></li>
<li><p>timePoints : timepoints for which to extract APD points</p></li>
<li><p>dorsal_thres : float between 0 and 1, threshold for COM extraction</p></li>
<li><dl class="simple">
<dt>anteriorChannel<span class="classifier">int, which channel of training to use if training</span></dt><dd><p>is used for extracting COM from probability cloud</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>posteriorChannel<span class="classifier">int, which channel of training to use if training</span></dt><dd><p>is used for extracting COM from probability cloud</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>dorsalChannel<span class="classifier">int, which channel of training to use if training</span></dt><dd><p>is used for extracting COM from probability cloud</p>
</dd>
</dl>
</li>
<li><p>overwrite : bool, overwrite previous results on disk</p></li>
<li><p>preview_com : bool, inspect the centers of mass extraction</p></li>
<li><p>axorder : length 3 int array, permutation of axes if needed</p></li>
<li><dl class="simple">
<dt>smwindow<span class="classifier">float or int (optional, default=30)</span></dt><dd><p>number of timepoints over which we smooth</p>
</dd>
</dl>
</li>
<li><p>preview : bool (optional, default=false)</p></li>
<li><dl class="simple">
<dt>autoAP<span class="classifier">bool whether or not to extract A-P points using an automatic</span></dt><dd><p>method using the moments of inertia of the mesh
(optional, default=false)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>custom_apts<span class="classifier">a custom set of 3D anterior points</span></dt><dd><p>(optional, default=[])</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>custom_ppts<span class="classifier">a custom set of 3D posterior points</span></dt><dd><p>(optional, default=[])</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
</dl>
<dl class="simple">
<dt>apdv_pts_for_centerline.h5 (rawapdvname, tubi.fileName.apdv)</dt><dd><p>Raw points (centers of mass if training-based) for A, P, and D in
subsampled pixels, in probability data space coordinate system. (note
this is downsampled by ssfactor)
Saved to fullfile(meshDir, ‘centerline/apdv_pts_for_centerline.h5’)</p>
</dd>
<dt>tubi.fileName.dpt</dt><dd><p>txt file with dorsal COM for APDV definition</p>
</dd>
</dl>
<p>rawapdvmatname=fullfile(tubi.dir.cntrline, ‘apdv_pts_for_centerline.mat’)</p>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeLBSoverTime">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeLBSoverTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeLBSoverTime" title="Permalink to this definition">#</a></dt>
<dd><p>results = computeLBSoverTime(tubi, options)
Compute Laplace-Beltrami spectral decomposition of the sequence of
deformations over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool (default = false)</span></dt><dd><p>overwrite previous results on disk</p>
</dd>
<dt>overwriteImages<span class="classifier">bool (default = false)</span></dt><dd><p>overwrite figures of previous results on disk</p>
</dd>
<dt>convert_to_period<span class="classifier">bool (default=false)</span></dt><dd><p>convert all timestamps to period</p>
</dd>
<dt>T<span class="classifier">numeric (default=NaN)</span></dt><dd><p>number of timepoints per period if data is periodic in time</p>
</dd>
<dt>t0<span class="classifier">int (default=tubi.t0set())</span></dt><dd><p>timestamp to mark as t=0</p>
</dd>
<dt>decompT<span class="classifier">int (defualt = t0)</span></dt><dd><p>The time for which the mesh Laplacian eigenbasis will be
constructed</p>
</dd>
<dt>NLBSModes<span class="classifier">int (default = 200)</span></dt><dd><p>The number of Laplacien eigenvectors to calculate</p>
</dd>
<dt>NmodesToView<span class="classifier">int (default= 5)</span></dt><dd><p>how many modes to plot individually on the reference surface
configuration</p>
</dd>
<dt>nTimePoints2RmEnds<span class="classifier">int (default= 0)</span></dt><dd><p>how many timepoints to remove from the beginning and end of the
timeseries. This is useful if the first and last few datapoints are
noisy</p>
</dd>
<dt>drawArrowsInLBSPlane<span class="classifier">bool (default= false)</span></dt><dd><p>a plotting option, to draw arrows showing trajectory from
timepoint to timepoint in 2D LBS projective planes</p>
</dd>
<dt>drawArrowsInLBS3D<span class="classifier">bool (default=false)</span></dt><dd><p>a plotting option, to draw arrows showing trajectory from
timepoint to timepoint in LBS space</p>
</dd>
<dt>meshChoice<span class="classifier">cell of strings or single string</span></dt><dd><p>(default={‘Lagrangian’, ‘sphi’})
the mesh style to use for computing PIV.</p>
</dd>
<dt>axPairs<span class="classifier">optional int array (default=[1,2;1,3;2,3])</span></dt><dd><p>pairs of mode numbers to plot in 2d projective planes (modes are
ordered by rank)</p>
</dd>
<dt>plotArrowsOnModes<span class="classifier">bool</span></dt><dd><p>plot arrows on the surfaces for mode decompositions</p>
</dd>
<dt>nArrows<span class="classifier">int</span></dt><dd><p>subsampling factor for quiverplot on modes, only used if
plotArrowsOnModes == true</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>results</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>cell of structs with fields</p>
</dd>
</dl>
<dl class="simple">
<dt>saves fullfile(tubi.dir.LBSoverTime, meshChoice, sprintf(‘lbsResults_%s.mat’, lbsType)) ;</dt><dd><p>where meshChoice is either ‘Lagrangian’ or ‘sphi’</p>
</dd>
</dl>
<p>saves figures to fullfile(tubi.dir.LBSoverTime, meshChoice)</p>
<p>Dillon Cislo + NPMitchell 2022</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeLocalSurfacePatch">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeLocalSurfacePatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">pts</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeLocalSurfacePatch" title="Permalink to this definition">#</a></dt>
<dd><p>Make local surface parameterization enclosing pts in pullback space
(could be used for computing angle between two cells during T1s)</p>
<p>Note: additional points can be found in mapped space via
newpts = barycentricMap2d(subm.f, subm.u, subm.V2D_scaled_detg, pts)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>coordSys : str specifier
overwrite : bool
buffer : float or int or numeric
bufferX : float or int or numeric, trumps buffer for X dim
bufferY : float or int or numeric, trumps buffer for Y dim
preview : preview
scaleByMetric : bool</p>
<blockquote>
<div><dl class="simple">
<dt>rescale parameterization to have det(g) approx 1 on either:</dt><dd><ul>
<li><p>faces queried by pts (if both imW and imH are not supplied)</p></li>
<li><p>in window com(pts) +/- [imW*0.5, imH*0.5]</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>scaleByMetricComponents<span class="classifier">bool</span></dt><dd><p>rescale parameterization to approximate isothermal coordinates</p>
</dd>
<dt>imW<span class="classifier">numeric</span></dt><dd><p>if scaleByMetric or scaleByMetricComponents, supplying imW then
determines the width in X dimension of V2D parameterization in which
to query metric for fixing. If none supplied, uses pointLocation of pts
in the submesh to probe which faces are queried.
If supplied, probeMetricViaFaceLookup = false ;
(in units of quasi-embedding space –&gt; ie registered/flattened
embedding submesh units, should be close to units of QS.spaceUnits if
submesh is not too strongly curved in embedding space).</p>
</dd>
<dt>imH<span class="classifier">numeric</span></dt><dd><p>if scaleByMetric or scaleByMetricComponents, supplying imH then
determines the width in Y dimension of V2D parameterization in which
to query metric for fixing. If none supplied, uses pointLocation of pts
in the submesh to probe which faces are queried.
If supplied, probeMetricViaFaceLookup = false ;
(in units of quasi-embedding space –&gt; ie registered/flattened
embedding submesh units, should be close to units of QS.spaceUnits if
submesh is not too strongly curved in embedding space).</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>subm</strong> – f : (#faces x 3 int) face Connectivity List
v : (#vertices x 3 float) vertices in embedding space (must be 3D)
u : (#vertices x 2 float) original pullback coordinates of submesh
Vcut : (#vertices x 3 float) vertices in embedding space (must be 3D)</p>
<blockquote>
<div><p>This is typically the same as v, in which case it is not returned</p>
</div></blockquote>
<dl class="simple">
<dt>Fcut<span class="classifier">(#faces x 3 int) face Connectivity List of cutMesh submesh</span></dt><dd><p>This is typically the same as f, in which case it is not returned</p>
</dd>
<dt>Ucut<span class="classifier">(#vertices x 2 float) original pullback coordinates of submesh</span></dt><dd><p>This is typically the same as u, in which case it is not returned</p>
</dd>
<dt>V2D<span class="classifier">#parameterized</span></dt><dd><p>as-rigid-as-possible re-parameterization of the embedding in a
local patch of pullback space</p>
</dd>
</dl>
<p>V2D_scaled_detg : (returned if scaleByMetric==true)
V2D_scaled_g11g22 : (returned if scaleByMetricComponents==true)
connectivityCase : int indicator</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt>submesh is within single Cover (most common, disk-like)</dt><dd><p>–&gt; no problems here, all triangles are oriented
correctly</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>submesh has one edge on another cover, with some long faces,</dt><dd><p>but is still a topological disk, so we push those vertices
reaching across the branch cut to the other side so that
triangles are oriented correctly</p>
</dd>
</dl>
</li>
<li><p>submesh has faces on multiple covers (topological disk)</p></li>
<li><p>submesh spans the whole single Cover (topological annulus)</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>struct with fields</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#@TubULAR.visualizeSegmentationPatch" title="@TubULAR.visualizeSegmentationPatch"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">visualizeSegmentationPatch</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <a class="reference internal" href="#@TubULAR.visualizeDemoTracks" title="@TubULAR.visualizeDemoTracks"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">visualizeDemoTracks</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></p>
</div>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computePCAoverTime">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computePCAoverTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computePCAoverTime" title="Permalink to this definition">#</a></dt>
<dd><p>results = computePCAoverTime(tubi, options)
Compute Principal Component Analysis of the sequence of deformations over
time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool (default = false)</span></dt><dd><p>overwrite previous results on disk</p>
</dd>
<dt>overwriteImages<span class="classifier">bool (default = false)</span></dt><dd><p>overwrite figures of previous results on disk</p>
</dd>
<dt>convert_to_period<span class="classifier">bool (default=false)</span></dt><dd><p>convert all timestamps to period</p>
</dd>
<dt>T<span class="classifier">numeric (default=NaN)</span></dt><dd><p>number of timepoints per period if data is periodic in time</p>
</dd>
<dt>t0<span class="classifier">int (default=tubi.t0set())</span></dt><dd><p>timestamp to mark as t=0</p>
</dd>
<dt>NmodesToView<span class="classifier">int (default= 5)</span></dt><dd><p>how many modes to plot individually on the reference surface
configuration</p>
</dd>
<dt>nTimePoints2RmEnds<span class="classifier">int (default= 0)</span></dt><dd><p>how many timepoints to remove from the beginning and end of the
timeseries. This is useful if the first and last few datapoints are
noisy</p>
</dd>
<dt>drawArrowsInPCAPlane<span class="classifier">bool (default= false)</span></dt><dd><p>a plotting option, to draw arrows showing trajectory from
timepoint to timepoint in 2D PCA projective planes</p>
</dd>
<dt>drawArrowsInPCA3D<span class="classifier">bool (default=false)</span></dt><dd><p>a plotting option, to draw arrows showing trajectory from
timepoint to timepoint in PCA space</p>
</dd>
<dt>meshChoice<span class="classifier">cell of strings or single string</span></dt><dd><p>(default={‘Lagrangian’, ‘sphi’})
the mesh style to use for computing PIV.</p>
</dd>
<dt>axPairs<span class="classifier">optional int array (default=[1,2;1,3;2,3])</span></dt><dd><p>pairs of mode numbers to plot in 2d projective planes (modes are
ordered by rank)</p>
</dd>
<dt>plotArrowsOnModes<span class="classifier">bool</span></dt><dd><p>plot arrows on the surfaces for mode decompositions</p>
</dd>
<dt>nArrows<span class="classifier">int</span></dt><dd><p>subsampling factor for quiverplot on modes, only used if
plotArrowsOnModes == true</p>
</dd>
<dt>displacement_scale<span class="classifier">float</span></dt><dd><p>scale factor to multiply pca velocities by before advecting mesh
vertices by vn*v_pca –&gt; ie displace vertices for visualization by
vn*v_pca*displacement_scale.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>results</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>cell of structs with fields</p>
</dd>
</dl>
<dl class="simple">
<dt>saves fullfile(tubi.dir.PCAoverTime, meshChoice, sprintf(‘pcaResults_%s.mat’, pcaType)) ;</dt><dd><p>where meshChoice is either ‘Lagrangian’ or ‘sphi’</p>
</dd>
</dl>
<p>saves figures to fullfile(tubi.dir.PCAoverTime, meshChoice)</p>
<p>NPMitchell 2022</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeRicciMeshes">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeRicciMeshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeRicciMeshes" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>computeRicciMeshes(QS, options)</dt><dd><p>Compute all Ricci meshes (if flow converges) and plot aspect ratio for isothermal PB over time</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – resample : bool (default=true) ;</p>
</dd>
</dl>
<p>NPMitchell 2021</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.computeStartEndCOMs">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">computeStartEndCOMs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.computeStartEndCOMs" title="Permalink to this definition">#</a></dt>
<dd><p>[acom_sm, pcom_sm, dcom] = COMPUTEAPDCOMS(opts)
Compute the anterior, posterior, and dorsal centers of mass from training</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul class="simple">
<li><p>timePoints</p></li>
<li><p>dorsal_thres : float between 0 and 1</p></li>
<li><p>anteriorChannel : int</p></li>
<li><p>posteriorChannel</p></li>
<li><p>dorsalChannel</p></li>
<li><p>overwrite : bool</p></li>
<li><p>apdvoutdir : string</p></li>
<li><p>meshDir : string</p></li>
<li><p>preview_com : bool</p></li>
<li><p>check_slices : bool</p></li>
<li><p>axorder : length 3 int array</p></li>
<li><dl class="simple">
<dt>smwindow<span class="classifier">float or int (optional, default=30)</span></dt><dd><p>number of timepoints over which we smooth</p>
</dd>
</dl>
</li>
<li><p>preview : bool (optional, default=false)</p></li>
</ul>
</p>
</dd>
</dl>
<dl class="simple">
<dt>apdv_coms_from_training.h5 (rawapdvname, QS.fileName.apdv)</dt><dd><p>Raw centers of mass for A, P, and D in subsampled pixels, in
probability data space coordinate system
Saved to fullfile(meshDir, ‘centerline/apdv_coms_from_training.h5’)</p>
</dd>
<dt>QS.fileName.dcom</dt><dd><p>txt file with dorsal COM for APDV definition</p>
</dd>
</dl>
<p>rawapdvmatname=fullfile(QS.dir.cntrline, ‘apdv_coms_from_training.mat’)</p>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.coordinateSystemDemo">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">coordinateSystemDemo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.coordinateSystemDemo" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>COORDINATESYSTEMDEMO(tubi)</dt><dd><p>Draw coordinate system for currentTime stamp, presentation/publication
style.
Image for publication/presentation on method &amp; coordinate system
Create coordinate system charts visualization using smoothed meshes</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>coordSys : char (default=’sphism’, ‘sphi’, ‘uv’)
style : ‘curves’ or ‘surface’
exten : ‘.png’ or ‘.pdf’ or ‘.jpg’
interpreter : ‘latex’ or ‘default’</p>
<blockquote>
<div><p>whether to use the latex interpreter for axes labels</p>
</div></blockquote>
<p>normLongitudinal : bool
includeCenterline : bool
fillHoops : bool</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>figure saved to fullfile(tubi.dir.spcutMesh, …</em> – ‘coordinate_system_demo’, ‘coordinate_system_demo_zeta’) ;</p></li>
<li><p><em>figure saved to fullfile(tubi.dir.spcutMesh, …</em> – ‘coordinate_system_demo’, ‘coordinate_system_demo_phi’) ;</p></li>
<li><p><em>NPMitchell 2020-2022</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.fitPhiOffsetsViaTexture">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">fitPhiOffsetsViaTexture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.fitPhiOffsetsViaTexture" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>fit offsets in the DV direction of pullback mesh by measuring phase
correlation between current and previous frame</p>
</div></blockquote>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCellSegmentation2D">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCellSegmentation2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCellSegmentation2D" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>segment cell membranes in 2d pullback projections
NOTE: Dependency is Nick Noll’s tissueAnalysisSuite: this must be in
the current Matlab path.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – coordSys : coordinate system on which to compute the segmentation</p></li>
</ul>
</dd>
</dl>
<p>tissueAnalysisSuite fields are different than QuapSlap’s.
For tissueAnalysisSuite, we have:
vdat:</p>
<blockquote>
<div><p>nverts : neighbor list for vertices
ncells :
vertxcoord : column of data in which vertex lives
vertycoord : row of data in which each vertex lives</p>
</div></blockquote>
<dl class="simple">
<dt>cdat<span class="classifier">cell data</span></dt><dd><p>ncells : indices of neighboring cells
nverts : vertices that define the cell
centroid.coord(1) x position of cell centroid
centroid.coord(2) y position of cell centroid</p>
</dd>
<dt>bdat :</dt><dd><p>nverts
ncells
pix : linear indices of the pixels associated with that bond</p>
</dd>
</dl>
<p>Note on exterior calculus objects
d0 is an e x c matrix of exterior derivatives with +1 and -1s
at the endpts of each bond
d1 is a v x e matrix of exterior derivatives. Upstream is +1,
downstream is -1 when moving counterclockwise around a
tension plaquette.
d0 and d1 are matrices that take derivatives</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCellSegmentation3D">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCellSegmentation3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCellSegmentation3D" title="Permalink to this definition">#</a></dt>
<dd><p>In the code below, “aspect” typically means (a/b-1) = ars - 1</p>
<dl class="simple">
<dt>Define Q tensor for each cell by</dt><dd><p>Q =  q (n^T n - II/2), where q = (sqrt(I_1/I_2) - 1) is the
magnitude of the anisotropy</p>
</dd>
<dt>The Q tensor is related to the aspect ratio of cells via:</dt><dd><p>abs(norm(Q)) * 2 = <a href="#id3"><span class="problematic" id="id4">|ar|</span></a> - 1</p>
</dd>
</dl>
<p>The mratio</p>
<p>The factor of two arises on the LHS since the
norm(n’<a href="#id1"><span class="problematic" id="id2">*</span></a>n - Identity*0.5) = 0.5 for any unit vector n, and an isotropic
cell will have norm(Q) = 0.</p>
<p>NPMitchell 2021</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCellSegmentationPathlines3D">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCellSegmentationPathlines3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCellSegmentationPathlines3D" title="Permalink to this definition">#</a></dt>
<dd><p>generateCellSegmentation3D(QS, options)</p>
<blockquote>
<div><p>Load segmentation results from a timepoint t0Pathlines, advect the cell
polygons along pathlines from PIV, measure the segmentation properties
of the advected “tissue” pattern frozen in the Lagrangian frame as the
material deforms.</p>
</div></blockquote>
<p>NPMitchell 2021</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCurrentCutMesh">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCurrentCutMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">cutMeshOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCurrentCutMesh" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – The object for which we generate the currentTime’s cutMesh</p></li>
<li><p><strong>cutMeshOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>nsegs4path (int, optional, default=2)</dt><dd><p>How many segments of piecewise geodesics to draw to cut the
axisymmetric surface so that the cut does not change winding
number with respect to the previous timepoint’s cut around the
centerline</p>
</dd>
<dt>maxJitter (float, optional, default=100)</dt><dd><p>maximum displacement in mesh units to randomly displace nodes of
the path in a brute-force search for topologically connected path</p>
</dd>
<dt>maxTwChange (float, optional, default=0.15)</dt><dd><p>maximum allowed change in the value of the twist of the cutPath
with respect to the centerline, as compared to the previous
timepoint’s cutPath twist about the centerline. This is a soft
proxy for the topology change, but in practice it is superior to
the error-prone methods of measuring the (discrete-valued) winding
number explored thus far</p>
</dd>
<dt>definePDviaRicci_t0<span class="classifier">(bool, default=false)</span></dt><dd><p>Compute the pullback coords at t0 via Ricci flow, then use Orbifold
for other timepoints</p>
</dd>
<dt>useMaxDeviationPtsForCorrection<span class="classifier">bool, default = true)</span></dt><dd><p>If the twist of a given cutpath is out of bounds, try different
paths based on piecewise geodesics that have endpoints chosen based
on their distance from the previous cutpath. This makes adjacent
timepoints’ cutpaths similar to each other.</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCurrentPullbacks">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCurrentPullbacks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">cutMesh</span></em>, <em class="sig-param"><span class="pre">spcutMesh</span></em>, <em class="sig-param"><span class="pre">spcutMeshSm</span></em>, <em class="sig-param"><span class="pre">pbOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCurrentPullbacks" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>GENERATECURRENTPULLBACKS(QS, cutMesh, spcutMesh, spcutMeshSm, pbOptions)</dt><dd><p>Generate 2D images of tissue mapped from 3D. If save_as_stack is true,
then we generate a 3D stack of 2D images along the normal direction of
the surface.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pbOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool (default=false)</span></dt><dd><p>overwrite existing images on disk</p>
</dd>
<dt>generate_sphi<span class="classifier">bool (default=true)</span></dt><dd><p>create pullbacks in sphi coords</p>
</dd>
<dt>generate_relaxed<span class="classifier">bool (default=false)</span></dt><dd><p>create pullbacks in sphi coords, stretched along x to minimize
areal distortion (but not anisotropic distortion). So this is not
a conformal map.</p>
</dd>
<dt>generate_uv<span class="classifier">bool (default=false)</span></dt><dd><p>create pullbacks in uphi coords. This is a nearly conformal map.</p>
</dd>
<dt>generate_uphi<span class="classifier">bool (default=false)</span></dt><dd><p>create pullbacks in uphi coords</p>
</dd>
<dt>generate_spsm<span class="classifier">bool (default=false)</span></dt><dd><p>create pullbacks in uphi coords</p>
</dd>
<dt>generate_rsm<span class="classifier">bool (default=false)</span></dt><dd><p>create pullbacks in uphi coords</p>
</dd>
<dt>generate_pivPathline(s)<span class="classifier">bool (default=false)</span></dt><dd><p>create pullback images from piv pathlines</p>
</dd>
<dt>PSize<span class="classifier">int (default=5)</span></dt><dd><p>how many interpolation points along each side of a patch</p>
</dd>
<dt>EdgeColor<span class="classifier">colorspec (default=’none’)</span></dt><dd><p>color of mesh edges in pullback image</p>
</dd>
<dt>YLim<span class="classifier">1x2 float (default=[0 1])</span></dt><dd><p>Y extent of pullback image in v or phi coords</p>
</dd>
<dt>axisorder<span class="classifier">length 3 ints (default = [1 2 3 ])</span></dt><dd><p>axis permutation for the texture mesh</p>
</dd>
<dt>preTextureLambda<span class="classifier">float (default = 0)</span></dt><dd><p>If nonzero, apply laplacian smooth to mesh before rendering and
before moving along normal_shift (which occurs before texture
mapping)</p>
</dd>
<dt>Additional options as fields passed to texturePatch are</dt><dd><ul>
<li><p>pbOptions.imSize:       The size of the output image</p></li>
<li><dl class="simple">
<dt>pbOptions.baseSize:     The side length in pixels of the smallest</dt><dd><p>side of the output image when using the
tight mesh bounding box</p>
</dd>
</dl>
</li>
<li><p>pbOptions.xLim:         The x-bounds of the output image</p></li>
<li><p>pbOptions.yLim:         The y-bounds of the output image</p></li>
<li><dl class="simple">
<dt>pbOptions.pixelSearch:  The method of searching for the faces</dt><dd><dl class="simple">
<dt>containing pixel centers</dt><dd><ul>
<li><p>’AABB’ (requires GPToolBox)</p></li>
<li><p>’Default’ (MATLAB built-ins, faster than AABB)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pbOptions.numLayers:    The number of onion layers to create</dt><dd><p>Format is [ (num +), (num -) ]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pbOptions.layerSpacing: The spacing between adjacent onion layers</dt><dd><p>in units of pixels</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pbOptions.smoothIter:   Number of iterations of Laplacian mesh</dt><dd><p>smoothing to run on the mesh prior to
vertex normal displacement (requires
GPToolBox) (Default is 0)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pbOptions.vertexNormal: User supplied vertex unit normals to the</dt><dd><p>texture triangulation</p>
</dd>
</dl>
</li>
<li><p>pbOptions.Interpolant:  A pre-made texture image volume interpolant</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCurrentSPCutMesh">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCurrentSPCutMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">cutMesh</span></em>, <em class="sig-param"><span class="pre">spcutMeshOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCurrentSPCutMesh" title="Permalink to this definition">#</a></dt>
<dd><dl>
<dt>Note that the only output in APDV (spaceUnits) coordinates are</dt><dd><p>mss, mcline, avgpts, avgpts_ss</p>
<blockquote>
<div><p>spcutMesh.sphi
spcutMesh.v
spcutMesh.vn
spcutMesh.ringpath_ss
spcutMesh.radii_from_mean_uniform_rs  % from uniform DV sampling
spcutMesh.radii_from_avgpts
spcutMesh.mss         % from uniform DV sampling, also stored in centerline
spcutMesh.mcline      % from uniform DV sampling, also stored in centerline
spcutMesh.avgpts      % from uniform DV sampling, also stored in centerline
spcutMesh.avgpts_ss   % pathlength from uniform sampling, also</p>
<blockquote>
<div><p>stored in centerline, in QS.spaceUnits</p>
</div></blockquote>
<p>spcutMesh.ar          % affine scaling in X that minimizes isoareal energy
spcutMesh.phi0s       %
spcutMesh.phi0_fit    %</p>
</div></blockquote>
</dd>
</dl>
<p>Note that depending on the relative axisorder between data frame (TIFFs)
and the APDV frame, you might need to set phi0_sign to true which would
flip the sign of phi0 (added rather than subtracted from v in (u,v)).
This can be true even if QS.flipy is false for some nonstandard
circumstances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – <dl class="simple">
<dt>Note that the following properties are used:</dt><dd><p>tubi.phiMethod = (‘3dcurves’, ‘texture’, ‘combined’)
tubi.a_fixed = 2.0</p>
</dd>
</dl>
</p></li>
<li><p><strong>cutMesh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">cutMesh</span> <span class="pre">struct,</span> <span class="pre">optional</span></code></span>) – cutMesh with fields</p></li>
<li><p><strong>spcutMesh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">spcutMesh</span> <span class="pre">struct,</span> <span class="pre">optional</span></code></span>) – </p></li>
<li><p><strong>spcutMeshOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields,</span> <span class="pre">optional</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>save_phi0patch<span class="classifier">bool</span></dt><dd><p>show the relaxation steps of phi0 determination</p>
</dd>
<dt>iterative_phi0<span class="classifier">bool</span></dt><dd><p>iteratively determine phi0 until convergence</p>
</dd>
<dt>smoothingMethod<span class="classifier">str specifier (default=’none’)</span></dt><dd><p>method for smoothing phi0 wrt AP axis coordinate (ss)</p>
</dd>
</dl>
<p>textureAxisOrder : ‘xyz’, ‘yxz’, etc
smoothingWidth : int</p>
<blockquote>
<div><p>width of kernel for smoothing of phi0 that takes v-&gt;phi=v-phi0.
Must be odd if smoothingMethod==’savgol’, does not matter
if smoothingMethod==’none’</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>spcutMesh</strong> (<em>struct with fields</em>) – sphi: equal dv, resampled 3d points based on spcutMesh.sphi0</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateCurrentUVCutMesh">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateCurrentUVCutMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">cutMesh</span></em>, <em class="sig-param"><span class="pre">spcutMeshOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateCurrentUVCutMesh" title="Permalink to this definition">#</a></dt>
<dd><p>Create a rectilinear (but periodic in 2nd dim) parameterization of the
cutMesh with a nearly-conformal pullback projection uv.</p>
<blockquote>
<div><p>uvcutMesh.f
uvcutMesh.uv
uvcutMesh.v
uvcutMesh.vn</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – <dl class="simple">
<dt>Note that the following properties are used:</dt><dd><p>tubi.phiMethod = (‘3dcurves’, ‘texture’, ‘combined’)
tubi.a_fixed = 2.0</p>
</dd>
</dl>
</p></li>
<li><p><strong>cutMesh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">cutMesh</span> <span class="pre">struct,</span> <span class="pre">optional</span></code></span>) – cutMesh with fields</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields,</span> <span class="pre">optional</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>uvcutMesh</strong> (<em>struct with fields</em>) – uv:</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateFastMarchingCenterlines">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateFastMarchingCenterlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">cntrlineOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateFastMarchingCenterlines" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Extract centerlines for all timepoints in the QuapSlap instance</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> – <dl>
<dt>uses in particular</dt><dd><p>timePoints :
meshDir
flipy : bool (optional, default is true)</p>
<blockquote>
<div><p>APDV coordinate system is mirrored across XZ wrt data coordinate
system XYZ.</p>
</div></blockquote>
</dd>
</dl>
</p></li>
<li><p><strong>Options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul>
<li><dl class="simple">
<dt>overwrite<span class="classifier">bool (optional, default is false)</span></dt><dd><p>whether to overwrite previous results on disk</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>exponent<span class="classifier">float (optional, default is 1.0)</span></dt><dd><p>exponent of the distance transform to use as speed</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>res<span class="classifier">float (optional, default is 1.0)</span></dt><dd><p>resolution with which to sample data volume to build shortest path</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>xx, yy, zz<span class="classifier">Nx1 float or int arrays (optional)</span></dt><dd><p>coordinates of the data volume in which to find the shortest path</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>xyzlim<span class="classifier">3x1 or 3x2 or 1x3 float (required if xx,yy,zz not given)</span></dt><dd><p>extrema (maxima or maxima &amp; minima) of each dimension for mesh
extent</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>meshAPDVFileName<span class="classifier">str (optional)</span></dt><dd><p>If supplied, plot rotated and scaled centerline with the previously
saved APDV aligned meshes matching this filename pattern</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>reorient_faces<span class="classifier">bool (optional, default is true)</span></dt><dd><p>ensure proper face orientation on each mesh (slower but rigorous)</p>
</dd>
</dl>
</li>
</ul>
</p></li>
<li><p><strong>Outputs</strong> – </p></li>
<li><p><strong>-------</strong> – </p></li>
<li><p><strong>curves</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">centerline</span></code></span>) – [fullfile(outdir, name) ‘_centerline’ extenstr] ;</p></li>
<li><p><strong>timepoint</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">one</span> <span class="pre">for</span> <span class="pre">each</span></code></span>) – [fullfile(outdir, name) ‘_centerline’ extenstr] ;</p></li>
<li><p><strong>in</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">stored</span></code></span>) – [fullfile(outdir, name) ‘_centerline’ extenstr] ;</p></li>
<li><p><strong>APDV</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">centerline</span> <span class="pre">curves</span> <span class="pre">in</span> <span class="pre">RS</span> <span class="pre">frame</span> <span class="pre">(rotated</span> <span class="pre">and</span> <span class="pre">scaled</span> <span class="pre">to</span> <span class="pre">align</span> <span class="pre">with</span></code></span>) – coordsys), stored in:
skel_rs_outfn = [fullfile(outdir, name) ‘_centerline_scaled’ extenstr ]</p></li>
<li><p><strong>outDirs</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">1</span> <span class="pre">cell</span> <span class="pre">array</span></code></span>) – The 2 output directories: centerlineOutDir, outdir for images</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generatePathlineRicciMeshTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generatePathlineRicciMeshTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generatePathlineRicciMeshTimePoint" title="Permalink to this definition">#</a></dt>
<dd><p>generatePathlineRicciRicciMeshTimePoint(QS, tp, options)</p>
<blockquote>
<div><p>Compute Ricci flow pullback for pathline-advected vertices in
QS.dir.piv/pathlines/t0_####/quasiconformal/pb2pb/
which is the same as
QS.dir.pathlines.quasiconformal/pb2pb</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">quapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">(default=QS.t0)</span></code></span>) – timestamp of timepoint for which to generate Ricci flow mesh</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – <p>maxIter : int (default=100)
radiusTolerance : float (default=0.01)</p>
<blockquote>
<div><p>maximum allowed fractional deviation of Ricci flow solution inner
and outer radius from a true circle with fixed radius (variable
inner radius, fixed outer radius of 1)</p>
</div></blockquote>
<dl class="simple">
<dt>save_ims<span class="classifier">bool (default = true)</span></dt><dd><p>save images of the ricci flow solution</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>Ricci flow solution</em> – ricciFn = sprintf(QS.fullFileBase.ricciSolution, maxIter, tp)</p></li>
<li><p><em>ricciMesh has fields annulus and rectangle</em> – ricciMeshFn = sprintf(QS.fullFileBase.ricciMesh, maxIter, tp) ;</p></li>
<li><p><em>Beltrami coeff mu for this #iterations</em> – mufn = sprintf(QS.fullFileBase.ricciMu, maxIter, tp) ;</p></li>
<li><p><em>Images saved</em></p></li>
<li><p><em>————</em></p></li>
<li><p><em>Plot Ricci result in annulus</em> – fullfile(imDir, sprintf(‘%06d_RicciSolution.png’, tp)) ;</p></li>
<li><p><em>plot beltrami for Ricci flow</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowBeltrami.png’, tp)) ;</p></li>
<li><p><em>Plot just the bare triangulation</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowSolution.png’, tp)) ;</p></li>
<li><p><em>Histogram |mu| for each case</em> – fullfile(imDir, sprintf(‘%06d_BeltramiCoefficients.png’, tp)) ;</p></li>
<li><p><em>Image of corrected vertices on inner and outer annulus</em> – fullfile(imDir, sprintf(‘%06d_ricci_InnerCorrection.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_ricci_OuterCorrection.png’, tp)) ;</p></li>
<li><p><em>Orientation and branch cut</em> – fullfile(imDir, sprintf(‘%06d_DrhoDphi_flipped.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderInitial.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderFinal.png’, tp)) ;</p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateRawRicciMeshTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateRawRicciMeshTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateRawRicciMeshTimePoint" title="Permalink to this definition">#</a></dt>
<dd><p>Compute solution to Ricci flow for a given timepoint’s cylinderMesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">quapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">(default=QS.t0)</span></code></span>) – timestamp of timepoint for which to generate Ricci flow mesh</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – <p>maxIter : int (default=100)
radiusTolerance : float (default=0.01)</p>
<blockquote>
<div><p>maximum allowed fractional deviation of Ricci flow solution inner
and outer radius from a true circle with fixed radius (variable
inner radius, fixed outer radius of 1)</p>
</div></blockquote>
<dl class="simple">
<dt>save_ims<span class="classifier">bool (default = true)</span></dt><dd><p>save images of the ricci flow solution</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>Ricci flow solution</em> – ricciFn = sprintf(QS.fullFileBase.rawRicciSolution, maxIter, tp)</p></li>
<li><p><em>rawRicciMesh has fields annulus and rectangle</em> – rawRicciMeshFn = sprintf(QS.fullFileBase.rawRicciMesh, maxIter, tp) ;</p></li>
<li><p><em>Beltrami coeff mu for this #iterations</em> – mufn = sprintf(QS.fullFileBase.rawRicciMu, maxIter, tp) ;</p></li>
<li><p><em>Images saved</em></p></li>
<li><p><em>————</em></p></li>
<li><p><em>Plot Ricci result in annulus</em> – fullfile(imDir, sprintf(‘%06d_RicciSolution.png’, tp)) ;</p></li>
<li><p><em>plot beltrami for Ricci flow</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowBeltrami.png’, tp)) ;</p></li>
<li><p><em>Plot just the bare triangulation</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowSolution.png’, tp)) ;</p></li>
<li><p><em>Histogram |mu| for each case</em> – fullfile(imDir, sprintf(‘%06d_BeltramiCoefficients.png’, tp)) ;</p></li>
<li><p><em>Image of corrected vertices on inner and outer annulus</em> – fullfile(imDir, sprintf(‘%06d_ricci_InnerCorrection.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_ricci_OuterCorrection.png’, tp)) ;</p></li>
<li><p><em>Orientation and branch cut</em> – fullfile(imDir, sprintf(‘%06d_DrhoDphi_flipped.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderInitial.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderFinal.png’, tp)) ;</p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateRicciMeshTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateRicciMeshTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateRicciMeshTimePoint" title="Permalink to this definition">#</a></dt>
<dd><p>Compute solution to Ricci flow for each timepoint. If there is only one
timepoint, we by default flow the spcutMesh. Otherwise we by default flow
the spcutMeshSm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">quapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span> <span class="pre">(default=QS.t0)</span></code></span>) – timestamp of timepoint for which to generate Ricci flow mesh</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>resample<span class="classifier">bool (default = true)</span></dt><dd><p>perform isotropic resampling of the mesh before performing Ricci
flow to ensure vertex quality during operation</p>
</dd>
</dl>
<p>maxIter : int (default=100)
radiusTolerance : float (default=0.01)</p>
<blockquote>
<div><p>maximum allowed fractional deviation of Ricci flow solution inner
and outer radius from a true circle with fixed radius (variable
inner radius, fixed outer radius of 1)</p>
</div></blockquote>
<dl class="simple">
<dt>save_ims<span class="classifier">bool (default = true)</span></dt><dd><p>save images of the ricci flow solution</p>
</dd>
<dt>pathline_computation<span class="classifier">bool</span></dt><dd><p>compute the ricci flow for the pathline mesh of this timepoint</p>
</dd>
<dt>t0Pathlines</dt><dd><p>only used if pathline_computation, which pathline to look onto for
this timpoint (for example load the mesh for t=50 advected along
pathlines from t0=1).</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>Ricci flow solution</em> – ricciFn = sprintf(QS.fullFileBase.ricciSolution, maxIter, tp)</p></li>
<li><p><em>ricciMesh has fields annulus and rectangle</em> – ricciMeshFn = sprintf(QS.fullFileBase.ricciMesh, maxIter, tp) ;</p></li>
<li><p><em>Beltrami coeff mu for this #iterations</em> – mufn = sprintf(QS.fullFileBase.ricciMu, maxIter, tp) ;</p></li>
<li><p><em>Images saved</em></p></li>
<li><p><em>————</em></p></li>
<li><p><em>Plot Ricci result in annulus</em> – fullfile(imDir, sprintf(‘%06d_RicciSolution.png’, tp)) ;</p></li>
<li><p><em>plot beltrami for Ricci flow</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowBeltrami.png’, tp)) ;</p></li>
<li><p><em>Plot just the bare triangulation</em> – fullfile(imDir, sprintf(‘%06d_RicciFlowSolution.png’, tp)) ;</p></li>
<li><p><em>Histogram |mu| for each case</em> – fullfile(imDir, sprintf(‘%06d_BeltramiCoefficients.png’, tp)) ;</p></li>
<li><p><em>Image of corrected vertices on inner and outer annulus</em> – fullfile(imDir, sprintf(‘%06d_ricci_InnerCorrection.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_ricci_OuterCorrection.png’, tp)) ;</p></li>
<li><p><em>Orientation and branch cut</em> – fullfile(imDir, sprintf(‘%06d_DrhoDphi_flipped.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderInitial.png’, tp)) ;
fullfile(imDir, sprintf(‘%06d_phiOrderFinal.png’, tp)) ;</p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateSPCutMeshSmStack">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateSPCutMeshSmStack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">spcutMeshSmStackOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateSPCutMeshSmStack" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Create TIFF stacks of normally evolved smoothed meshes in (s, phi)
coordinate system.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>spcutMeshSmStackOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul>
<li><dl class="simple">
<dt>n_outward<span class="classifier">int</span></dt><dd><p>number of steps in positive normal direction to sample</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>n_inward<span class="classifier">int</span></dt><dd><p>number of steps in negative normal direction to sample</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>whether to overwrite spcutMeshSmStack on disk</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateSPCutMeshStack">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateSPCutMeshStack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">spcutMeshStackOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateSPCutMeshStack" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>generateSPCutMeshSmStack(QS, spcutMeshStackOptions)</dt><dd><p>Create TIFF stacks of normally evolved smoothed meshes in (s, phi)
coordinate system.
Same as generateSPCutMeshSmStack() but for non-smoothed (in time)
pullback images.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>spcutMeshStackOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul>
<li><dl class="simple">
<dt>n_outward<span class="classifier">int</span></dt><dd><p>number of steps in positive normal direction to sample</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>n_inward<span class="classifier">int</span></dt><dd><p>number of steps in negative normal direction to sample</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>whether to overwrite spcutMeshSmStack on disk</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.generateUVPrimeCutMeshes">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">generateUVPrimeCutMeshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.generateUVPrimeCutMeshes" title="Permalink to this definition">#</a></dt>
<dd><p>Generate pullbacks in the (u’,v’) coordinate system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>none</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.getCurrentData">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">getCurrentData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">adjustIV</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.getCurrentData" title="Permalink to this definition">#</a></dt>
<dd><p>IV = getCurrentData(tubi, adjustIV)
Load/return volumetric intensity data for current timepoint
Note: axis order permutation is applied here upon loading and
assignment to self (current tubi instance).
Note that the steps executed by this function depends on whether
xp is an ImSAnE experiment class or a simple struct belonging to the
TubULAR class instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">tubi</span> <span class="pre">class</span> <span class="pre">instance</span> <span class="pre">(self)</span></code></span>) – </p></li>
<li><p><strong>adjustIV</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(default=true)</span></code></span>) – apply the intensity adjustment stored in
tubi.data.adjustlow/high</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>IV</strong> – volumetric intensity data of current timepoint
Note this is also assigned to self as tubi.currentData.IV, so
avoiding a duplicate copy in RAM is useful for large data
by not returning an argument and instead calling
tubi.currentData.IV when needed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>#channels x 1 cell array of X*Y*Z intensities arrays</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.getMeshes">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">getMeshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">overwrite</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.getMeshes" title="Permalink to this definition">#</a></dt>
<dd><p>Obtain mesh surfaces of volumetric data (like ImSAnE’s surface
detection methods), here using integralDetector methods for
activecontouring</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> – </p></li>
<li><p><strong>overwrite</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">bool</span></code></span>) – <p>overwrite previous meshes on disk
preview : bool
tension :
prepressure
maxIterRelaxMeshSpikes : int &gt;=0 (default=1000)</p>
<blockquote>
<div><p>maximum number of iterations to relax spikes in the mesh</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>none</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>raw meshes as ply files</em></p></li>
<li><p><em>level sets as .mat files,</em></p></li>
<li><p><em>smoothed meshes as ply files</em></p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2022</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.helmholtzHodge">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">helmholtzHodge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.helmholtzHodge" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>helmholtzHodge(QS, options)</dt><dd><ul class="simple">
<li><p>Compute DEC divergence and DEC “curl” on 2d evolving surface in 3d.</p></li>
<li><p>Compute laplacian in covariant frame</p></li>
<li><p>Compute scalar fields representing rotational and harmonic components</p></li>
<li><p>Store all on disk.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>averagingStyle<span class="classifier">str (‘Lagrangian’, ‘simple’)</span></dt><dd><p>style in which velocities were averaged over time</p>
</dd>
<dt>alphaVal<span class="classifier">float</span></dt><dd><p>the opacity of the heatmap to overlay</p>
</dd>
<dt>invertImage<span class="classifier">bool</span></dt><dd><p>invert the data pullback under the velocity map</p>
</dd>
<dt>clipDiv<span class="classifier">float (default=5.0)</span></dt><dd><p>max allowed divergence measurement</p>
</dd>
<dt>clipRot<span class="classifier">float (default=0.5)</span></dt><dd><p>max allowed vorticity measurement</p>
</dd>
<dt>computeLaplacian<span class="classifier">bool (default = false)</span></dt><dd><p>compute the laplacian of the velocity field</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020/2021</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.initializeTubULAR">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">initializeTubULAR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">xp</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.initializeTubULAR" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Hidden method for instantiating TubULAR class</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">object</span> <span class="pre">whose</span> <span class="pre">properties</span> <span class="pre">to</span> <span class="pre">fill</span> <span class="pre">in</span> <span class="pre">with</span> <span class="pre">this</span> <span class="pre">function</span></code></span>) – </p></li>
<li><p><strong>xp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Imsane</span> <span class="pre">Experiment</span> <span class="pre">class</span> <span class="pre">instance</span> <span class="pre">belonging</span> <span class="pre">to</span> <span class="pre">tubi</span> <span class="pre">or</span> <span class="pre">struct</span></code></span>) – <p>if imsane class instance, tubular uses imsane fields to populate
metadata. Otherwise this needs to be a struct with fields</p>
<blockquote>
<div><p>fileMeta
expMeta</p>
</div></blockquote>
<p>See docs for entries in these fields and their descriptions.</p>
</p></li>
<li><p><strong>opts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>flipy<span class="classifier">bool</span></dt><dd><p>Set to true if lab coordinates are mirrored along some axis wrt to
data coords.</p>
</dd>
<dt>meshDir<span class="classifier">str</span></dt><dd><p>path to where meshes are stored and output will be placed</p>
</dd>
<dt>timeUnits<span class="classifier">str</span></dt><dd><p>units of time, for ex ‘min’</p>
</dd>
<dt>spaceUnits<span class="classifier">str</span></dt><dd><p>units of space, for ex ‘$mu$m’ for microns</p>
</dd>
<dt>nU<span class="classifier">int</span></dt><dd><p>resolution in the longitudinal direction, in number of sampling
points per proper length of the mesh</p>
</dd>
<dt>nV<span class="classifier">int</span></dt><dd><p>resolution in the circumferential direction, in number of sampling
points per circumference</p>
</dd>
<dt>lambda<span class="classifier">optional float</span></dt><dd><p>smoothing applied to fields on a mesh before computation of DEC
derivatives</p>
</dd>
<dt>lambda_mesh<span class="classifier">optional float</span></dt><dd><p>smoothing (diffusion constant) applied to mesh vertices before
computation of DEC fields</p>
</dd>
<dt>lambda_err<span class="classifier">optional float</span></dt><dd><p>additional smoothing for fields derived from DEC fields</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020-2022</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.interpolateOntoPullbackXY">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">interpolateOntoPullbackXY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">XY</span></em>, <em class="sig-param"><span class="pre">scalar_field</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.interpolateOntoPullbackXY" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>interpolateOntoPullbackXY(tubi, XY, scalar_field, options)</dt><dd><p>Interpolate scalar field defined on current mesh onto
supplied pullback coordinates. Input scalar_field may be
defined on vertices or faces. Automatically detects whether
field is at 1x mesh resolution or higher. The pixel locations of the
pullback are computed from scratch via options.Lx and options.Ly, not
passed directly.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – class for which to interpolate onto the pullback XY</p></li>
<li><p><strong>XY</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Nx2</span> <span class="pre">numeric</span> <span class="pre">array</span></code></span>) – positions at which to evaluate scalar field</p></li>
<li><p><strong>scalar_field</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Nx1</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – the field to interpolate, defined on either vertices or faces of the
current mesh</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>imCoords<span class="classifier">str pullback specifier (default=QS.piv.imCoords)</span></dt><dd><p>coordinate system of the pullback space</p>
</dd>
<dt>sfLocation<span class="classifier">’vertices’ or ‘faces’ (default=’vertices’)</span></dt><dd><p>evaluation location of the scalar field on currentMesh</p>
</dd>
<dt>iMethod<span class="classifier">’linear’, ‘cubic’, or ‘nearest’ (default=’linear’)</span></dt><dd><p>interpolation method for scalar field</p>
</dd>
<dt>Lx<span class="classifier">int or float (optional, saves time if supplied)</span></dt><dd><p>extent of pullback image space in horizontal dimension</p>
</dd>
<dt>Ly<span class="classifier">int or float (optional, saves time if supplied)</span></dt><dd><p>extent of pullback image space in vertical dimension</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sf</strong> – scalar field evaluated onto pullback coordinates</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nx1 float array</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureBeltramiCoefficient">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureBeltramiCoefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureBeltramiCoefficient" title="Permalink to this definition">#</a></dt>
<dd><p>Previous version measured instantaneous mu as well, which was the
Beltrami coefficient to the current (nearly) conformal pullback.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>t0Pathlines<span class="classifier">numeric (default = QS.t0)</span></dt><dd><p>timepoint used to define Lagrangian/material frame for mu
measurements to be made with respect to</p>
</dd>
<dt>coordSys<span class="classifier">str specifier (‘ricci’, ‘uvprime’ or ‘sp’)</span></dt><dd><p>coordinate system in which pathlines are computed</p>
</dd>
</dl>
<p>overwrite : bool, overwrite previous results on disk
climit : limit for caxis of scalar fields Re(mu) and Im(mu)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureBeltramiCoefficientPullbackToPullback">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureBeltramiCoefficientPullbackToPullback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureBeltramiCoefficientPullbackToPullback" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Measure the Beltrami using the Ricci flow pullback of a (advected) mesh</dt><dd><p>at some timepoint t1 relative to the pullback of the same
(non-advected) mesh at t0. Since Ricci flow is a conformal map, these
Beltramis should equal those of the 3D embedding to 2D pullback
comparison performed in QS.measureBeltramiCoefficient().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>t0Pathlines<span class="classifier">numeric (default = QS.t0)</span></dt><dd><p>timepoint used to define Lagrangian/material frame for mu
measurements to be made with respect to</p>
</dd>
<dt>coordSys<span class="classifier">str specifier (‘ricci’, ‘uvprime’ or ‘sp’)</span></dt><dd><p>coordinate system in which pathlines are computed</p>
</dd>
<dt>maxIter<span class="classifier">int</span></dt><dd><p>only used if coordSys == ‘ricci’, #ricci iterations</p>
</dd>
</dl>
<p>overwrite : bool, overwrite previous results on disk
climit : limit for caxis of scalar fields Re(mu) and Im(mu)</p>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QS.measureBeltramiCoefficient</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></p>
</div>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureCurvatures">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureCurvatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureCurvatures" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>measureCurvatures(QS, options)</dt><dd><p>Measure and plot mean and gaussian curvature for smoothed meshes
(QS.currentMesh.spcutMeshSm) for each timepoint</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – Current QuapSlap object</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite results on disk</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureDxDyStrainFiltered">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureDxDyStrainFiltered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureDxDyStrainFiltered" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Compute strain along bonds that lie along dx and dy in pullback space
from integrated pathlines deforming mesh vertices. Filter the results
heavily in space.
Measurements are taken with respect to fixed Lagrangian frame.
Plot results in 2d and/or 3d for each timepoint.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – overwrite : bool, overwrite data on disk
overwriteImages : bool, overwrite images of results on disk
plot_comparison : bool, plot a comparison with DEC traceful dilation
median_filter_strainRates : bool</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureMetricKinematics">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureMetricKinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureMetricKinematics" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>[gdot_apM, HH_apM, divv_apM, veln_apM] = measureMetricKinematics(QS, options)</dt><dd><p>Measure degree of incompressibility of the flow on the evolving surface
Out-of-plane motion is v_n * 2H, where v_n is normal velocity and H is
mean curvature.
In-plane motion considered here is div(v_t) where v_t is tangential
velocity on the curved surface.
The difference div(v_t) - vn*2H = Tr[g^{-1} dot{g}], which is a measure
of isotropic metric change over time (dot is the partial derivative wrt
time).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the QS experiment timePoints</p>
</dd>
<dt>alphaVal<span class="classifier">float</span></dt><dd><p>the opacity of the heatmap to overlay</p>
</dd>
<dt>invertImage<span class="classifier">bool</span></dt><dd><p>invert the data pullback under the velocity map</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureMetricStrainRate">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureMetricStrainRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureMetricStrainRate" title="Permalink to this definition">#</a></dt>
<dd><p>Advect the current mesh by the current raw velocities and measure
differences between metric of advected (future) mesh and current mesh
(reference). This gives a measurement of the strain rate tensor with
units related to the pullback space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePIV2d">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePIV2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePIV2d" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Measure 2d PIV on pullbacks in some coordinate system (coordSys),
either using PIVLab (default is use_PIVLab=true) or using a simple
phasecorrelation with a single pass at a single fixed window size.</p>
<p>Note that this code does NOT use the time interval tubi.timeInterval
between frames, since the 2D PIV connects the optical flow of adjacent
frames and does not measure velocity in any physical sense.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – <p>use_PIVLab : bool (default=True)
edgeLength : size of interrogation window in pixels
histequilize : bool (default=True)</p>
<blockquote>
<div><p>perform histogram equilization before piv calculation</p>
</div></blockquote>
<dl class="simple">
<dt>timePoints<span class="classifier">Nx1 numeric (default is tubi.xp.fileMeta.timePoints)</span></dt><dd><p>the timepoints for which to compute PIV</p>
</dd>
<dt>coordSys<span class="classifier">string specifier (default is tubi.piv.imCoords)</span></dt><dd><p>the image coordinates in which PIV is to be performed</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>none</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><strong>tubi.fileName.pivRaw.raw</strong> (<em>‘x’, ‘y’, ‘u’, ‘v’, ‘u_filtered’, ‘v_filtered’</em>)</p></li>
<li><p><em>NPMitchell 2022</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePIV3d">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePIV3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePIV3d" title="Permalink to this definition">#</a></dt>
<dd><dl>
<dt>measurePIV3D(tubi, options)</dt><dd><p>Measure 3d flows from PIV results on smoothed (s,phi) MIP pullbacks.
Note that this code accounts for the time interval tubi.timeInterval in
the dt between frames.</p>
<dl class="simple">
<dt>default options for created MIPS (done before this method) are:</dt><dd><p>pbOptions = struct() ;
pbOptions.overwrite = false ;
pbOptions.numLayers = [5, 5] ;
pbOptions.layerSpacing = 0.75 ;
pbOptions.generate_rsm = true ;
pbOptions.generate_spsm = true ;
pbOptions.generate_sphi = false ;
tubi.data.adjustlow = 1.00 ;
tubi.data.adjusthigh = 99.999 ;
tubi.generateCurrentPullbacks([], [], [], pbOptions) ;</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>includeMeshesInPullbackInspection<span class="classifier">bool (default=false)</span></dt><dd><p>draw an advected mesh and reference
mesh on top of pullback images to inspect</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the tubi experiment timePoints</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>m0XY</strong> (<em>Px2 float: 2d mesh vertices in pullback image pixel space [pullback pix]” ;</em>)</p></li>
<li><p><strong>m0f</strong> (<em>#facesx3 float: mesh connectivity list” ;</em>)</p></li>
<li><p><strong>m0v3d</strong> (<em>Px3 float: 3d mesh coordinates in embedding pixel space [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>x0</strong> (<em>QxR float: x value of 2d velocity evaluation coordinates in pullback image pixel space [pullback pix]” ;</em>)</p></li>
<li><p><strong>y0</strong> (<em>QxR float: y value of 2d velocity evaluation coordinates in pullback image pixel space [pullback pix]” ;</em>)</p></li>
<li><p><strong>pt0</strong> (<em>Nx3 float: 3d location of evaluation points [mesh pix]” ;</em>)</p></li>
<li><p><strong>pt1</strong> (<em>Nx3 float: 3d location of advected point in next mesh [mesh pix]” ;</em>)</p></li>
<li><p><strong>v0</strong> (<em>Nx3 float: 3d velocity [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>v0n</strong> (<em>Nx1 float: normal velocity [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>v0t</strong> (<em>Nx3 float: tangential velocity in 3d [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>facenormals</strong> (<em>#faces x 3 float: face normals for all faces [unitless, mesh pix / mesh pix]” ;</em>)</p></li>
<li><p><strong>v3dfaces</strong> (<em>#faces x 3 float: face-centered velocities in embedding space [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>v3dvertices</strong> (<em>#mesh vertices x 3 float: vertex-centered velocities in embedding space [mesh pix / dt]” ;</em>)</p></li>
<li><p><strong>v0_rs</strong> (<em>Nx3 float: rotated/scaled 3d velocities [um/min]” ;</em>)</p></li>
<li><p><strong>v0n_rs</strong> (<em>Nx3 float: scaled normal velocities [um/min]” ;</em>)</p></li>
<li><p><strong>v0t_rs</strong> (<em>Nx3 float: rotated/scaled tangential 3d velocities [um/min]” ;</em>)</p></li>
<li><p><strong>normals_rs</strong> (<em>Nx3 float: normal vector of field faces in 3d [unitless, um/um]” ;</em>)</p></li>
<li><p><strong>v0t2d</strong> (<em>Nx2 float: in-plane velocity [pullback pix / dt]” ;</em>)</p></li>
<li><p><strong>g_ab</strong> (<em>Nx2x2 float: pullback metric” ;</em>)</p></li>
<li><p><strong>dilation</strong> (<em>Nx1 float: dilation of face from 3d to 2d (A_2d [pullback_pix^2] / A_3d [mesh_pix^2])” ;</em>)</p></li>
<li><p><strong>jac</strong> (<em>#faces x 1 cell: jacobian of 3d-&gt;2d transformation” ;</em>)</p></li>
<li><p><strong>fieldfaces</strong> (<em>Nx1 int: face indices into spcutMesh where v defined” ;</em>)</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePIV3dMultiChannel">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePIV3dMultiChannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePIV3dMultiChannel" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Measure 3d flows from PIV results on smoothed (s,phi) MIP pullbacks
for each channel</p>
<dl class="simple">
<dt>default options for created MIPS (done before this method) are:</dt><dd><p>pbOptions = struct() ;
pbOptions.overwrite = false ;
pbOptions.numLayers = [5, 5] ;
pbOptions.layerSpacing = 0.75 ;
pbOptions.generate_rsm = true ;
pbOptions.generate_spsm = true ;
pbOptions.generate_sphi = false ;
QS.data.adjustlow = 1.00 ;
QS.data.adjusthigh = 99.999 ;
QS.generateCurrentPullbacks([], [], [], pbOptions) ;</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the QS experiment timePoints</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p>m0XY : Px2 float: 2d mesh vertices in pullback image pixel space [pullback pix[” ;
m0f : #facesx3 float: mesh connectivity list” ;
m0v3d : Px3 float: 3d mesh coordinates in embedding pixel space [mesh pix / dt]” ;
x0 : QxR float: x value of 2d velocity evaluation coordinates in pullback image pixel space [pullback pix]” ;
y0 : QxR float: y value of 2d velocity evaluation coordinates in pullback image pixel space [pullback pix]” ;
pt0 : Nx3 float: 3d location of evaluation points [mesh pix]” ;
pt1 : Nx3 float: 3d location of advected point in next mesh [mesh pix]” ;
v0 : Nx3 float: 3d velocity [mesh pix / dt]” ;
v0n : Nx1 float: normal velocity [mesh pix / dt]” ;
v0t : Nx3 float: tangential velocity in 3d [mesh pix / dt]” ;
facenormals : #faces x 3 float: face normals for all faces [unitless, mesh pix / mesh pix]” ;
v3dfaces : #faces x 3 float: face-centered velocities in embedding space [mesh pix / dt]” ;
v3dvertices : #mesh vertices x 3 float: vertex-centered velocities in embedding space [mesh pix / dt]” ;
v0_rs : Nx3 float: rotated/scaled 3d velocities [um/min]” ;
v0n_rs : Nx3 float: scaled normal velocities [um/min]” ;
v0t_rs : Nx3 float: rotated/scaled tangential 3d velocities [um/min]” ;
normals_rs : Nx3 float: normal vector of field faces in 3d [unitless, um/um]” ;
v0t2d : Nx2 float: in-plane velocity [pullback pix / dt]” ;
g_ab : Nx2x2 float: pullback metric” ;
dilation : Nx1 float: dilation of face from 3d to 2d (A_2d [pullback_pix^2] / A_3d [mesh_pix^2])” ;
jac : #faces x 1 cell: jacobian of 3d-&gt;2d transformation” ;
fieldfaces : Nx1 int: face indices into spcutMesh where v defined” ;</p>
<p>NPMitchell 2020-2021</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePathlineMetric">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePathlineMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePathlineMetric" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>measurePathlineStrain(QS, options)</dt><dd><p>Integrate the metric strain rate along Lagrangian pathlines.
Allow for median filtering along Lagrangian pathlines to avoid
spurious spikes in accumulated strain.
Plot results in 2d and/or 3d for each timepoint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – overwrite : bool, overwrite data on disk
overwriteImages : bool, overwrite images of results on disk
plot_comparison : bool, plot a comparison with DEC traceful dilation
median_filter_strainRates : bool</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePathlineMetricKinematics">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePathlineMetricKinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePathlineMetricKinematics" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Query the metric Kinematics along lagrangian pathlines.
Plot results as kymographs and correlation plots.
Out-of-plane motion is v_n * 2H, where v_n is normal velocity and H is
mean curvature.
In-plane motion considered here is div(v_t) where v_t is tangential
velocity on the curved surface.
The difference div(v_t) - vn*2H = Tr[g^{-1} dot{g}], which is a measure
of isotropic metric change over time (dot is the partial derivative wrt
time).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs : bool
plot_kymographs_cumsum : bool
plot_correlations : bool
plot_gdot_correlations : bool
plot_gdot_decomp : bool</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePathlineStrain">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePathlineStrain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePathlineStrain" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Compute strain from integrated pathlines deforming mesh vertices.
Measurements are taken with respect to fixed Lagrangian frame.
Plot results in 2d and/or 3d for each timepoint.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – overwrite : bool, overwrite data on disk
overwriteImages : bool, overwrite images of results on disk
plot_comparison : bool, plot a comparison with DEC traceful dilation
median_filter_strainRates : bool</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePathlineStrainRate">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePathlineStrainRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePathlineStrainRate" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Query the metric strain rate along lagrangian pathlines.
Plot results as kymographs.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs : bool
plot_kymographs_cumsum : bool
plot_gdot_correlations : bool
plot_gdot_decomp : bool</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePathlineVelocities">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePathlineVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePathlineVelocities" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>measurePullbackStreamlines(QS, options)</dt><dd><p>Use pathlines of optical flow in pullback space to query velocities
and average along pathlines.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool, default=false</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>t0<span class="classifier">int, default=QS.t0set()</span></dt><dd><p>timestamp at which the pathlines form a grid onto mesh vertices,
mesh face barycenters, or PIV evaluation points</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>outStruct = struct(‘v2dum’, v2dMum, …</em> – ‘v2d’, v2dM, …
‘vn’, vnM, …
‘v3d’, vM, …
‘vf’, vfM, …
‘vv’, vvM, …
‘v2dsmum’, v2dsmMum, …
‘v2dsm’, v2dsmM, …
‘vnsm’, vnsmM, …
‘v3dsm’, vsmM, …
‘vfsm’, vfsmM, …
‘vvsm’, vvsmM ) ;</p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>fvsmM   = sprintf(QS.fileName.pathlines.velocities.v3dsm, t0) ;</em></p></li>
<li><p><em>fvfsmM  = sprintf(QS.fileName.pathlines.velocities.vfsm, t0) ;</em></p></li>
<li><p><em>fvnsmM  = sprintf(QS.fileName.pathlines.velocities.vnsm, t0) ;</em></p></li>
<li><p><em>fvvsmM  = sprintf(QS.fileName.pathlines.velocities.vvsm, t0) ;</em></p></li>
<li><p><em>fv2dsmM = sprintf(QS.fileName.pathlines.velocities.v2dsm, t0) ;</em></p></li>
<li><p><em>fv2dsmMum = sprintf(QS.fileName.pathlines.velocities.v2dsmum, t0) ;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measurePullbackPathlines">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measurePullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measurePullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Measure pathlines of optical flow in pullback space.
These pathlines can then be used to query velocities or other
properties that are parameterized by pullback coordinates.
For example, we average velocites along Lagrangian pathlines.
For another example, to build a Lagrangian-frame measure of divergence
of tangential velocity, div(v_t), we can query div(v_t) at the coords
of the PullbackPathlines (via interpolation of div(v_t) defined on
pullback mesh vertices).</p>
</div></blockquote>
<p>NOTE: Updated 2022-07 so that if the pullback is doubleCover of the
surface, we ensure that velocities and pathlines of periodic positions
respect the periodicity of the surface. We do this by explicitly
AVERAGING the displacments of each cover, then clipping to a single
cover cylinderCutMesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>maxIter<span class="classifier">int (default=100)</span></dt><dd><p>#Ricci steps for refMesh.u_ricci and beltrami calculation</p>
</dd>
</dl>
</p></li>
<li><p><strong>disk</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Saves</span> <span class="pre">to</span></code></span>) – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>refMesh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">sprintf(QS.fileName.pathlines.refMesh,</span> <span class="pre">t0)</span></code></span>) – reference mesh in 3d and its pullback that is conformal mapping to the
plane, created using Ricci flow at time t0</p></li>
<li><p><strong>piv_pathlines_v3d</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">v3d:</span> <span class="pre">sprintf(QS.fileName.pathlines.v3d,</span> <span class="pre">t0)</span></code></span>) – Advected PIV evaluation coordinates in XY pixel space make pathlines
in XY.</p></li>
<li><p><strong>piv_pathlines_v3d</strong> – Advect refMesh vertex coordinates in XY pixel space in optical flow to
make pathlines in XY (pixel space).</p></li>
<li><p><strong>piv_pathlines_v3d</strong> – Advect refMesh face barycenters in XY pixel space to make pathlines</p></li>
<li><p><strong>piv_pathlines_v3d</strong> – Embedding coordinates of advected PIV evaluation coordinates, pushed
into APDV coordinate system</p></li>
<li><p><strong>piv_pathlines_v3d</strong> – Embedding coordinates of advected refMesh vertices, pushed into APDV
coordinate system</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#@TubULAR.timeAverageVelocities" title="@TubULAR.timeAverageVelocities"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">timeAverageVelocities</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <a class="reference internal" href="#@TubULAR.pullbackPathlines" title="@TubULAR.pullbackPathlines"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">pullbackPathlines</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></p>
</div>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureStrainRate">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureStrainRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureStrainRate" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Compute epsilon = 1/2 (nabla_i v_j + nabla_j v_i) - vN b_{ij}
The result on faces is smoothed insofar as the velocities are smoothed
with options.lambda and the mesh (governing b_{ij}) is smoothed with
options.labmda_mesh.
The result on vertices is additionally smoothed via a quasi-1D spectral
filter governed by options.nmodes and options.zwidth.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">object</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – lambda : float
lambda_mesh : float
overwrite : bool
overwriteImages : bool
preview : bool
averagingStyle : str specifier (‘Lagrangian’ or ‘Simple’)
samplingResolution : ‘1x’ or ‘2x’
debug : bool</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>(none)</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>strainRate results in QS.dir.strainRate.measurements/strainRate_%06d.mat</em> – -&gt; one result per timepoint, with spectral smoothing applied to
vertex-based results</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureSurfaceAreaVolume">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureSurfaceAreaVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureSurfaceAreaVolume" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>MEASURESURFACEAREAVOLUME(QS, OPTIONS)</dt><dd><p>Compute the mesh surface area and volume over time</p>
</dd>
</dl>
<p>QS.alignMeshesAPDV()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – Current QuapSlap object</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite results on disk</p>
</dd>
<dt>preivew<span class="classifier">bool, default=QS.plotting.preview</span></dt><dd><p>display intermediate results</p>
</dd>
<dt>thres_fraca<span class="classifier">float, default=1.0</span></dt><dd><p>threshold fractional change in area above which we say the area and
volume are NaN</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureUVPrimePathlineFeatureIDs">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureUVPrimePathlineFeatureIDs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureUVPrimePathlineFeatureIDs" title="Permalink to this definition">#</a></dt>
<dd><p>Interactively identify one longitudinal (zeta) position per feature for
Lagrangian pathlines using field measurements along Lagrangian pathlines
of the coordinate system (u’,v’) [conformally mapped to plane]</p>
<p>One can use, for example, radius of the pathlines on the mesh from the
centerline, or the normal velocity, or dz – the ratio of projected
(embedding space) proper distance of a unit vector along longitudinal
mesh direction to the pullback distance along the longitudinal direction,
or dp – similar for circumferential direction, divv – the divergence of
the velocity field, etc. Uses two fields to identify the feature
positions along the longitudinal dimension.</p>
<p>todo: generalize beyond vP pathline array</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">measurePathlineFeatureIDs.m</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">object</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>pathlineType</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">str</span> <span class="pre">specifier</span> <span class="pre">('vertices',</span> <span class="pre">'piv',</span> <span class="pre">'faces')</span></code></span>) – whether pathlines in question thread through mesh vertices, piv
evaluation coordinates, or face barycenters at t=t0Pathlines</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – overwrite : bool
field1 : str specifier (‘radius’, ‘dz’, ‘dp’, ‘divv’, ‘veln’)
field2 : str specifier (‘radius’, ‘dz’, ‘dp’, ‘divv’, ‘veln’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>featureIDs</strong> (<em>#features x 1 int array</em>) – longitudinal pullback coordinate for features, as an index into the
pullback pathlines (which are grid-like).</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureUVPrimePathlines">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureUVPrimePathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureUVPrimePathlines" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>measurePullbackPathlines(QS, options)</dt><dd><p>Measure pathlines of optical flow in pullback space.
These pathlines can then be used to query velocities or other
properties that are parameterized by pullback coordinates.
For example, we average velocites along Lagrangian pathlines.
For another example, to build a Lagrangian-frame measure of divergence
of tangential velocity, div(v_t), we can query div(v_t) at the coords
of the PullbackPathlines (via interpolation of div(v_t) defined on
pullback mesh vertices). For now assumes all pullbacks are the same
size – for ex, 2000 x 2000 pixels.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>smoothing_sigma<span class="classifier">float</span></dt><dd><p>Gaussian kernel standard deviation if &gt;0 for smoothing in-plane
displacements from piv readout</p>
</dd>
</dl>
</p></li>
<li><p><strong>disk</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Saves</span> <span class="pre">to</span></code></span>) – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>sprintf(QS.fileName.pathlines_uvprime.XY</strong> – </p></li>
<li><p><strong>;</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">t0)</span></code></span>) – </p></li>
<li><p><strong>sprintf(QS.fileName.pathlines_uvprime.vXY</strong> – </p></li>
<li><p><strong>;</strong> – </p></li>
<li><p><strong>sprintf(QS.fileName.pathlines_uvprime.fXY</strong> – </p></li>
<li><p><strong>;</strong> – </p></li>
<li><p><strong>sprintf(QS.fileName.pathlines_uvprime.XYZ</strong> – </p></li>
<li><p><strong>;</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#@TubULAR.timeAverageVelocities" title="@TubULAR.timeAverageVelocities"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">timeAverageVelocities</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <a class="reference internal" href="#@TubULAR.pullbackPathlines" title="@TubULAR.pullbackPathlines"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">pullbackPathlines</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></p>
</div>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureWrithe">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureWrithe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureWrithe" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>MEASUREWRITHE(QS, OPTIONS)</dt><dd><p>Compute the centerline length and writhe and save to disk</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – Current QuapSlap object</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite results on disk</p>
</dd>
<dt>preivew<span class="classifier">bool, default=QS.plotting.preview</span></dt><dd><p>display intermediate results</p>
</dd>
<dt>Wr_style<span class="classifier">str specifier, default=’Levitt’ ;</span></dt><dd><p>which style of writhe calculation to plot</p>
</dd>
<dt>black_figs<span class="classifier">bool</span></dt><dd><p>plot figures with black background rather than white</p>
</dd>
<dt>flipy_centerline<span class="classifier">bool</span></dt><dd><p>flip the centerline data y –&gt; -y (inverts sign of writhe)</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.measureXYZLims">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">measureXYZLims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.measureXYZLims" title="Permalink to this definition">#</a></dt>
<dd><p>Redo calculation of XYZ limits</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotAlignedMeshesPretty">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotAlignedMeshesPretty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotAlignedMeshesPretty" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot aligned APDV meshes with pretty lighting for timeseries</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous images on disk</p>
</dd>
<dt>ApplyAmbientOcclusion: Determines if the texture</dt><dd><p>colors should be modified by the ambient occlusion of the
underlying triangulation {‘false’}</p>
</dd>
<dt>AmbientOcclusion:    #Vx1 list of ambient occlusion</dt><dd><p>values</p>
</dd>
<dt>AmbientOcculsionFactor: A scalar between [0,1]</dt><dd><p>determining how strongly the ambient occlusion modifies the
texture mapping {1}</p>
</dd>
<dt>AmbientOcculsionSamples: The number of samples to use</dt><dd><p>when computing the ambient occlusion {1000}</p>
</dd>
<dt>Unoriented: Treat the surface as unoriented when</dt><dd><p>applying ambient occlusion {‘false’}</p>
</dd>
</dl>
<p>AddLights: Will add lighting to the plot {‘false’}</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><strong>metadat.mat</strong> (<em>mat file with variables ‘metadat’</em>) – options for how plotting was performed</p></li>
<li><p><em>NPMitchell 2021</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotAverageVelocitiesTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotAverageVelocitiesTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotAverageVelocitiesTimePoint" title="Permalink to this definition">#</a></dt>
<dd><p>plotTimeAvgVelocitiesTimePoint(QS, tp, options)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>vnsm    :
v2dsmum :
overwrite : bool</p>
<blockquote>
<div><p>overwrite previous results</p>
</div></blockquote>
<dl class="simple">
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the QS experiment timePoints</p>
</dd>
<dt>alphaVal<span class="classifier">float</span></dt><dd><p>the opacity of the heatmap to overlay</p>
</dd>
<dt>invertImage<span class="classifier">bool</span></dt><dd><p>invert the data pullback under the velocity map</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotClineXSections">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotClineXSections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotClineXSections" title="Permalink to this definition">#</a></dt>
<dd><p>Plot fancy “cross-section” view of centerlines, saved to DVhoop
centerline directory</p>
<p>NPMitchell 2021</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotCutPath">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotCutPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">cutMesh</span></em>, <em class="sig-param"><span class="pre">cutP</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotCutPath" title="Permalink to this definition">#</a></dt>
<dd><p>Plot the cut path of a cylinderCutMesh on the mesh in 3D and save image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">object</span></code></span>) – </p></li>
<li><p><strong>cutMesh</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">cutMesh</span> <span class="pre">object</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – v : vertices
f : face connectivity list</p></li>
<li><p><strong>cutP</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">3D</span> <span class="pre">path</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">cut</span> <span class="pre">on</span> <span class="pre">the</span> <span class="pre">cylinderCutMesh</span></code></span>) – </p></li>
<li><p><strong>2019</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotMetric">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotMetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotMetric" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotMetricKinematics">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotMetricKinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotMetricKinematics" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the metric Kinematics as kymographs and correlation plots
Out-of-plane motion is v_n * 2H, where v_n is normal velocity and H is
mean curvature.
In-plane motion considered here is div(v_t) where v_t is tangential
velocity on the curved surface.
The difference div(v_t) - vn*2H = 1/2 Tr[g^{-1} dot{g}], which is a
measure of isotropic metric change over time (dot is the partial
derivative wrt time).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs : bool
plot_kymographs_cumsum : bool
plot_correlations : bool
plot_gdot_correlations : bool
plot_gdot_decomp : bool
plot_Hgdot : bool (default = false)</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotMetricKinematicsTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotMetricKinematicsTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotMetricKinematicsTimePoint" title="Permalink to this definition">#</a></dt>
<dd><p>Plot the metric Kinematics, either for all timepoints or for a single
timepoint. This function is called by measureMetricKinematics()
TODO: also allow the function to be a standalone method to plot all
timepoints if tp is not passed to options.</p>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineMetricKinematics">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineMetricKinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineMetricKinematics" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the metric Kinematics along pathlines as kymographs and
correlation plots.
Out-of-plane motion is v_n * 2H, where v_n is normal velocity and H is
mean curvature.
In-plane motion considered here is div(v_t) where v_t is tangential
velocity on the curved surface.
The difference div(v_t) - vn*2H = 1/2 Tr[g^{-1} dot{g}], which is a
measure of isotropic metric change over time (dot is the partial
derivative wrt time).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs         : bool
plot_kymographs_cumsum  : bool
plot_correlations       : bool
plot_fold_kinematics    : bool
plot_lobe_kinematics    : bool</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineStrain">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineStrain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineStrain" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the strain (from piv pathlines) along pathlines as kymographs and
correlation plots. These are computed via finite differencing of
pathline mesh metrics. That is, vertices are advected along piv flow
and projected into 3D from pullback space to embedding, then the
metrics g_{ij} of those meshes are measured and differenced.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs         : bool
plot_kymographs_cumsum  : bool
plot_correlations       : bool
plot_fold_strainRate    : bool
plot_lobe_strainRate    : bool
plot_fold_strain        : bool
plot_lobe_strain        : bool</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineStrainRate">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineStrainRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineStrainRate" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the strain rate along pathlines as kymographs and
correlation plots. These are computed via finite differencing of
pathline mesh metrics. That is, vertices are advected along piv flow
and projected into 3D from pullback space to embedding, then the
metrics g_{ij} of those meshes are measured and differenced.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – plot_kymographs         : bool
plot_kymographs_cumsum  : bool
plot_correlations       : bool
plot_fold_strainRate    : bool
plot_lobe_strainRate    : bool
plot_fold_strain        : bool
plot_lobe_strain        : bool</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineStrainRateTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineStrainRateTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineStrainRateTimePoint" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the traceful and traceless components of the strain rate tensor
defined at pathlines moving in the domain of parameterization over
time.
Here, plot the trajectories as immobile in a grid. Uses vertex
pathlines.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – timepoint in units of (1/QS.timeInterval) * QS.timeUnits</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineStrainTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineStrainTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineStrainTimePoint" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>plotPathlineStrainRateTimePoint(tubi, tp, options)</dt><dd><p>Plot the traceful and traceless components of the strain rate tensor
defined at pathlines moving in the domain of parameterization over
time.
Here, plot the trajectories as immobile in a grid. Uses vertex
pathlines.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – timepoint in units of (1/tubi.timeInterval) * tubi.timeUnits</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>t0Pathline<span class="classifier">int</span></dt><dd><p>Lagrangian frame is taken to be cutMesh of this timepoint</p>
</dd>
<dt>LagrangianFrameStyle<span class="classifier">str specifier (‘sphi’ ‘uvprime’)</span></dt><dd><p>what kind of cutmesh pullback is strain measured relative to. In
other words, if we computed strain with respect to a fixed material
frame in (zeta, phi) coordinates defined at timepoint t0Pathline,
then this would be ‘zphi’.</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineVelocities">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineVelocities" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Use pathlines of optical flow in pullback space to query velocities
and average along pathlines.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool, default=false</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>t0<span class="classifier">int, default=QS.t0set()</span></dt><dd><p>timestamp at which the pathlines form a grid onto mesh vertices,
mesh face barycenters, or PIV evaluation points</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotPathlineVelocitiesTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotPathlineVelocitiesTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotPathlineVelocitiesTimePoint" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the velocities defined on PIV evaluation points in Lagrangian
coordinates.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>gridTopology<span class="classifier">str</span></dt><dd><p>’rectilinear’ or ‘triangulated’
triangulate anew each timepoint or keep grid structure</p>
</dd>
</dl>
<p>vnsm    :
v2dsmum :
overwrite : bool</p>
<blockquote>
<div><p>overwrite previous results</p>
</div></blockquote>
<dl class="simple">
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the QS experiment timePoints</p>
</dd>
<dt>alphaVal<span class="classifier">float</span></dt><dd><p>the opacity of the heatmap to overlay</p>
</dd>
<dt>invertImage<span class="classifier">bool</span></dt><dd><p>invert the data pullback under the velocity map</p>
</dd>
<dt>qscale<span class="classifier">float</span></dt><dd><p>scale for quiver arrows</p>
</dd>
<dt>sampleIDx<span class="classifier">int array (default=[])</span></dt><dd><p>vertex indices at which to draw vectors. If not empty, uses
‘custom’ for subsamplingMethod. If empty, computes new
farthestPointSearch sampling</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotSPCutMeshSmSeriesUtility">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotSPCutMeshSmSeriesUtility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">coordsys</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotSPCutMeshSmSeriesUtility" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Using (s,phi) pullback cutmeshes, smooth coord system in time via
simple triangular pulse averaging of positions in embedding space</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – Current QuapSlap object</p></li>
<li><p><strong>coordsys</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">str</span> <span class="pre">specifier</span> <span class="pre">('spcutMeshSm',</span> <span class="pre">'spcutMeshSmRS',</span> <span class="pre">'spcutMeshSmRSC')</span></code></span>) – What kind of mesh to plot.
Any string without ‘RS’ or ‘RSC’ directs to plotting ‘spcutMeshSmRSC’
Any string with RS directs to plotting ‘spcutMeshSm’
Any string with RSC directs to plotting ‘spcutMeshSmRS’</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite results on disk</p>
</dd>
<dt>preivew<span class="classifier">bool, default=QS.plotting.preview</span></dt><dd><p>display intermediate results</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotSeriesOnSurfaceTexturePatch">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotSeriesOnSurfaceTexturePatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em>, <em class="sig-param"><span class="pre">TexturePatchOptions</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotSeriesOnSurfaceTexturePatch" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>PLOTDATAONSURFACETEXTUREPATCH(xp, xyzlim, rot, trans)</dt><dd><p>Plot intensity data timeseries on 3d mesh timeseries</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite options on disk as .mat</p>
</dd>
<dt>texture_shift<span class="classifier">float (optional, default=0)</span></dt><dd><p>shift of texture mesh, but not physical mesh</p>
</dd>
</dl>
</p></li>
<li><p><strong>TexturePatchOptions</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <ul>
<li><p>Options.PSize: default=5</p></li>
</ul>
<p>Special option, defines the image texture size
for each individual polygon.  A lower number gives a more
pixelated texture {64}</p>
<ul>
<li><p>Options.Dilation: default=tubi.APDV.resolution</p></li>
</ul>
<p>Special option, defines the units of space (pix2um, for ex)</p>
<ul>
<li><p>Options.Translation: default=tubi.APDV.trans</p></li>
</ul>
<p>Special option, defines the translation
vector applied after rotation on all surfaces</p>
<ul>
<li><p>Options.Rotation: default=tubi.APDV.rot</p></li>
</ul>
<p>Special option, defines the dilation factor
applied to all surfaces after rotation and translation</p>
<ul>
<li><p>Options.ApplyAmbientOcclusion: Determines if the texture</p></li>
</ul>
<p>colors should be modified by the ambient occlusion of the
underlying triangulation {‘false’}</p>
<ul>
<li><p>Options.AmbientOcclusion:    #Vx1 list of ambient occlusion</p></li>
</ul>
<p>values</p>
<ul>
<li><p>Options.AmbientOcculsionFactor: A scalar between [0,1]</p></li>
</ul>
<p>determining how strongly the ambient occlusion modifies the
texture mapping {1}</p>
<ul>
<li><p>Options.AmbientOcculsionSamples: The number of samples to use</p></li>
</ul>
<p>when computing the ambient occlusion {1000}</p>
<ul>
<li><p>Options.Unoriented: Treat the surface as unoriented when</p></li>
</ul>
<p>applying ambient occlusion {‘false’}</p>
<ul>
<li><p>Options.AddLights: Will add lighting to the plot {‘false’}</p></li>
<li><p>Options.ScalarField: A vertex-based or face based scalar field</p></li>
</ul>
<p>used to augment texture mapping with external color</p>
<ul>
<li><p>Options.ScalarCLim: The colormap limits used to display the</p></li>
</ul>
<p>scalar field. By default it will use the full range of values in
the scalar field</p>
<ul>
<li><p>Options.ScalarColorMap: The colormap used to display the scalar</p></li>
</ul>
<p>field.  Either a a string corresponding to a built-in MATLAB
colormap or a user supplied #Cx3 colormap {‘parula’}</p>
<ul>
<li><p>Options.ScalarAlpha: A scalar between [0,1] determining</p></li>
</ul>
<p>how the transparency of the overlay of the scalar field mapping
{0.1};</p>
<ul>
<li><p>Options.VertexNormals: #Vx3 list of vertex unit normals</p></li>
<li><p>Options.isRGB : bool, whether input arrays are R,G,B channels</p></li>
<li><p>Options.isFalseColor : bool, whether to colorize with unique</p></li>
</ul>
<p>color for each channel</p>
<ul>
<li><p>Options.falseColors : #channels x 3 list of colors for each</p></li>
</ul>
<p>channel</p>
<ul>
<li><p>Options.Imax: float, maximum value for the data interpolant</p></li>
</ul>
<p>object above which we clip the intensity</p>
<ul>
<li><p>Options.Imin: float, minimum value for the data interpolant</p></li>
</ul>
<p>object below which we clip the intensity</p>
<ul>
<li><p>Options.extrapolationMethod:
‘nearest’ | ‘linear’ | ‘nearest’ | ‘next’ | ‘previous’ |
‘pchip’ | ‘cubic’ | ‘spline’ | ‘makima’ | ‘none’,</p></li>
</ul>
<p>what extrapolation to use outside of the domain of data
interpolation values</p>
<ul>
<li><p>Options.smoothIter : int, how many iterations of Laplcaian</p></li>
</ul>
<p>smoothing to apply before normal displacement</p>
<ul>
<li><p>Options.numLayers : default=[1, 1]</p></li>
</ul>
<p>length 2 array of ints, number of layers in
positive, negative directions for MIP option</p>
<ul>
<li><p>Options.layerSpacing :  float, default=2</p></li>
</ul>
<p>distance between layers in texture space pixel coordinate units</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><strong>metadat.mat</strong> (<em>mat file with variables ‘metadat’ and ‘Options’</em>) – options for how to plot and compute texturepatches</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotStrainRate">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotStrainRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotStrainRate" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>plotStrainRateTimePoint(QS, tp, options)</dt><dd><p>Plot the traceful and traceless components of the strain rate tensor
defined on each face, both for individual timepoints, and
also over time as kymographs</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – timepoint in units of (1/QS.timeInterval) * QS.timeUnits</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>NPMitchell 2020</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotStrainRate3DFiltered">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotStrainRate3DFiltered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotStrainRate3DFiltered" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>load spatially-smoothed
epsilon = 1/2 (nabla_i v_j + nabla_j v_i) - vN b_{ij} from disk,
smooth with time filter and plot in 3d</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">object</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – lambda : float
lambda_mesh : float
overwrite : bool
preview : bool
averagingStyle : str specifier (‘Lagrangian’ or ‘Simple’)
samplingResolution : ‘1x’ or ‘2x’
debug : bool
nTimePoints</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
</ul>
</p>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotStrainRateTimePoint">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotStrainRateTimePoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">tp</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotStrainRateTimePoint" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Plot the traceful and traceless components of the strain rate tensor
defined on each face, using vertex-based results loaded from disk.
Note that the vertex-based results are more heavily smoothed (via
spectral filtering) than the face-based results on disk.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Additional</span> <span class="pre">optional</span> <span class="pre">fields</span> <span class="pre">of</span> <span class="pre">options</span> <span class="pre">that</span> <span class="pre">are</span> <span class="pre">already</span> <span class="pre">specified</span> <span class="pre">by</span></code></span>) – </p></li>
<li><p><strong>tp</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">int</span></code></span>) – timepoint in units of (1/tubi.timeInterval) * tubi.timeUnits</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>Overwrite existing results on disk</p>
</dd>
<dt>mesh<span class="classifier">struct with fields f,v</span></dt><dd><p>current Mesh, allowed to be supplied to allow speedup (prevents
delay from loading cutMesh from disk)</p>
</dd>
<dt>cutMesh<span class="classifier">struct with fields f,v, pathPairs, nU, nV</span></dt><dd><p>current cutMesh, allowed to be supplied to allow speedup (prevents
delay from loading cutMesh from disk)</p>
</dd>
<dt>clim_trace<span class="classifier">2x1 numeric</span></dt><dd><p>color limits for the colormap/bar of the isotropic strain rate</p>
</dd>
<dt>clim_deviatoric<span class="classifier">2x1 numeric</span></dt><dd><p>color limits for the colormap/bar of the deviatoric strain rate</p>
</dd>
<dt>samplingResolution<span class="classifier">’1x’ or ‘resampled’</span></dt><dd><p>currently only 1x resolution is allowed</p>
</dd>
<dt>averagingStyle<span class="classifier">’Lagrangian’ or ‘none’</span></dt><dd><p>currently we have restricted the velocity averaging style in
tubular to either be Lagrangian averaging or none</p>
</dd>
<dt>debug<span class="classifier">bool</span></dt><dd><p>if true, show intermediate results</p>
</dd>
<dt>plot_comparison<span class="classifier">bool</span></dt><dd><p>plot a comparison between trace of measured strain rate and
measured DEC divergence minus H*normal velocity, where H is the
mean curvature.</p>
</dd>
</dl>
</p></li>
<li><p><strong>tubi</strong> – </p></li>
<li><p><strong>are</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">metadata</span> <span class="pre">but</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">overwritten</span> <span class="pre">by</span> <span class="pre">including</span> <span class="pre">them</span> <span class="pre">in</span> <span class="pre">options</span></code></span>) – lambda = tubi.smoothing.lambda ;
lambda_mesh = tubi.smoothing.lambda_mesh ;
nmodes = tubi.smoothing.nmodes ;
zwidth = tubi.smoothing.zwidth ;</p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.plotTimeAvgVelocities">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">plotTimeAvgVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.plotTimeAvgVelocities" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>plotTimeAvgVelSimple(QS, options)</dt><dd><p>Save images of the velocity field over time that has been “simply”
averaged over time in-place in the surface-Lagrangian pullback. That
is, the velocity field at location (u,v) has been averaged in time with
previous and later timepoints at the same pullback location (u,v).
For samplingResolution, all fields plotted in this method depend only
on the PIV sampling settings</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">numeric 1D array</span></dt><dd><p>the timepoints to consider for the measurement. For ex, could
choose subset of the QS experiment timePoints</p>
</dd>
<dt>alphaVal<span class="classifier">float</span></dt><dd><p>the opacity of the heatmap to overlay</p>
</dd>
<dt>invertImage<span class="classifier">bool</span></dt><dd><p>invert the data pullback under the velocity map</p>
</dd>
</dl>
<p>vtscale = 5 ;      % um / min
vnscale = 2 ;      % um / min
vscale = 2 ;       % um / min
alphaVal = 0.7 ;   % alpha for normal velocity heatmap
washout2d = 0.5 ;  % lightening factor for data
qsubsample = 5 ;   % quiver subsampling in pullback space</p>
</p></li>
</ul>
</dd>
</dl>
<p>NPMitchell 2020</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.prepareIlastik">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">prepareIlastik</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.prepareIlastik" title="Permalink to this definition">#</a></dt>
<dd><p>Prepaere stack for Ilastik segmentation. This outputs an h5
file of subsampled intensity data at isotropic resolution
on which to train.</p>
<p>prepareIlastik(stack)</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.processCorrectedCellSegmentation2D">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">processCorrectedCellSegmentation2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.processCorrectedCellSegmentation2D" title="Permalink to this definition">#</a></dt>
<dd><p>Unfinished code – Lin working on it.
ToDo:</p>
<p>tissueAnalysisSuite fields are different than QuapSlap’s.
For tissueAnalysisSuite, we have:
Vdat:</p>
<blockquote>
<div><p>nverts : neighbor list for vertices
ncells :
vertxcoord : column of data in which vertex lives
vertycoord : row of data in which each vertex lives</p>
</div></blockquote>
<dl class="simple">
<dt>Cdat<span class="classifier">cell data</span></dt><dd><p>ncells : indices of neighboring cells
nverts : vertices that define the cell
centroid.coord(1) x position of cell centroid
centroid.coord(2) y position of cell centroid</p>
</dd>
<dt>Bdat :</dt><dd><p>nverts
ncells
pix : linear indices of the pixels associated with that bond</p>
</dd>
</dl>
<p>Note on exterior calculus objects
d0 is an e x c matrix of exterior derivatives with +1 and -1s
at the endpts of each bond
d1 is a v x e matrix of exterior derivatives. Upstream is +1,
downstream is -1 when moving counterclockwise around a
tension plaquette.
d0 and d1 are matrices that take derivatives</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.pullbackPathlines">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">pullbackPathlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">x0</span></em>, <em class="sig-param"><span class="pre">y0</span></em>, <em class="sig-param"><span class="pre">t0</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.pullbackPathlines" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Create paths in pullback space (in pixels, XY) by following optical
flow of PIV measured on QS.pivimCoords pullbacks.
For non-standard PIV pathline propagation (such as uvprime coords),
supply piv, Lx, and Ly in options.
Note: I’ve chosen to use spatial smoothing via Gaussian blur rather
than temporal smoothing of velocities (as is done in metric kinematics)
for this code. This can be changed by setting
QS.piv.smoothing_sigma == 0. Ie, if QS.piv.smoothing_sigma &gt; 0, then
we advect in the smoothed piv results.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>x0</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">n*m</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – x coordinates in pullback pixels to start pathlines at t0</p></li>
<li><p><strong>y0</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">n*m</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – y coordinates in pullback pixels to start pathlines at t0</p></li>
<li><p><strong>t0</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">float</span></code></span>) – time at which to begin the pathlines, must be member of
QS.xp.fileMeta.timePoints. Note this is not the index of timePoints,
but the element of timePoints (ie a timeStamp)</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
<dt>timePoints<span class="classifier">1d int array</span></dt><dd><p>the timpepoints along which to map pathlines that intersect with
(x0, y0) at t0</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>XX</strong> (<em>#timePoints x size(x0, 1) x size(x0, 2) float array</em>) – the pullback pixel X coordinates of the pathline spanning timePoints</p></li>
<li><p><strong>YY</strong> (<em>#timePoints x size(x0, 1) x size(x0, 2) float array</em>) – the pullback pixel Y coordinates of the pathline spanning timePoints</p></li>
<li><p><em>NPMitchell 2020</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.sliceMeshEndcaps">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">sliceMeshEndcaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">opts</span></em>, <em class="sig-param"><span class="pre">methodOpts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.sliceMeshEndcaps" title="Permalink to this definition">#</a></dt>
<dd><p>SLICEMESHENDCAPS()
Create cut meshes with endcaps removed
Note that a later step involves cutMesh, which slices along AP.
Noah Mitchell 2019
This version relies on Gabriel Peyre’s toolbox called
toolbox_fast_marching/</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">TubULAR</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – class instance for which we cut off endcaps of mesh</p></li>
<li><p><strong>opts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – adist_thres
pdist_thres
adist_thres2
pdist_thres2
aCapMethod
pCapMethod
aOffset
pOffset
aOffset2
pOffset2
aOffsetRate
pOffsetRate
aOffset2Rate
pOffset2Rate
aDistRate
pDistRate
tref
custom_aidx
custom_pidx</p></li>
<li><p><strong>methodOpts</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">optional</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>tref<span class="classifier">int (timestamp, not index)</span></dt><dd><p>reference time stamp for dorsal definition, after and before which
we point match to find the “dorsal” boundary vertex on each endcap</p>
</dd>
<dt>quickScan<span class="classifier">bool</span></dt><dd><p>first iterate through all points with large dt between frames to
check that settings are good, then go back and compute each frame
in order</p>
</dd>
</dl>
</p></li>
<li><p><strong>Prerequisites</strong> – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>pints</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">alignMeshesAPDV()</span> <span class="pre">after</span> <span class="pre">identifying</span> <span class="pre">APD</span></code></span>) – </p></li>
<li><p><strong>extractCenterlineSeries()</strong> – </p></li>
</ul>
</dd>
</dl>
<p>First run extract_centerline.m or extractCenterlineSeries() before
running this code.
Run this code only after identifying anterior (A), posterior (P), and
dorsal anterior (D) points via computeAPDpoints().</p>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.smoothDynamicSPhiMeshes">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">smoothDynamicSPhiMeshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.smoothDynamicSPhiMeshes" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>SMOOTHDYNAMICSPHIMESHES(QS, options)</dt><dd><p>Using (s,phi) pullback cutmeshes, smooth coord system in time via
simple triangular pulse averaging of positions in embedding space
while preserving the pullback mesh.
Note that the computed geodesic distance along the mesh is preserved in
the pullback: mesh extent spcutMeshSm.u(:, 1) varies from (0, GeoLength)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – Current QuapSlap object</p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <dl class="simple">
<dt>width<span class="classifier">int, default=4</span></dt><dd><p>half-width of tripulse smoothing filter on output meshes</p>
</dd>
<dt>overwrite<span class="classifier">bool, default=false</span></dt><dd><p>overwrite results on disk</p>
</dd>
<dt>preivew<span class="classifier">bool, default=QS.plotting.preview</span></dt><dd><p>display intermediate results</p>
</dd>
</dl>
</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.timeAverageVelocities">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">timeAverageVelocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">tubi</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.timeAverageVelocities" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>measurePullbackStreamlines(tubi, options)</dt><dd><p>Use pathlines of optical flow in pullback space to query velocities
and average along Lagrangian pathlines.
Default is to weight velocities contributions with a time width 5
weighted by tripulse filter.
To avoid any averaging in time, set twidth = 0 ;</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tubi</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>twidth : average over (t-twidth, t+twidth) timepoints
XYkernel : float
plotOptions : optional struct with fields</p>
<blockquote>
<div><p>vtscale : float
vnscale : float</p>
</div></blockquote>
<dl class="simple">
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite previous results</p>
</dd>
<dt>preview<span class="classifier">bool</span></dt><dd><p>view intermediate results</p>
</dd>
</dl>
</p></li>
<li><p><strong>disk</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">Saves</span> <span class="pre">to</span></code></span>) – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>vsmM</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(nX*nY)</span> <span class="pre">x</span> <span class="pre">3</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – 3d velocities at PIV evaluation coordinates in spaceUnits/dt rs</p></li>
<li><p><strong>vfsmM</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(2*nU*(nV-1))</span> <span class="pre">x</span> <span class="pre">3</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – 3d velocities at face barycenters in um/dt rs</p></li>
<li><p><strong>vnsmM</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(nX*nY)</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – normal velocity at PIV evaluation coordinates in spaceUnits/dt rs</p></li>
<li><p><strong>vvsmM</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(nU*nV)</span> <span class="pre">x</span> <span class="pre">3</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – 3d velocities at (1x resolution) mesh vertices in spaceUnits/dt rs</p></li>
<li><p><strong>v2dsmM</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(nX*nY)</span> <span class="pre">x</span> <span class="pre">2</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – 2d velocities at PIV evaluation coordinates in pixels/dt</p></li>
<li><p><strong>v2dsmMum</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">(#timePoints-1)</span> <span class="pre">x</span> <span class="pre">(nX*nY)</span> <span class="pre">x</span> <span class="pre">2</span> <span class="pre">float</span> <span class="pre">array</span></code></span>) – 2d velocities at PIV evaluation coordinates in scaled pix/dt, but
proportional to spaceUnits/dt (scaled by dilation of map)</p></li>
<li><p><strong>2020</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></span>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.visualizeDemoTracks">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">visualizeDemoTracks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">Options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.visualizeDemoTracks" title="Permalink to this definition">#</a></dt>
<dd><p>Load demo tracks (segmented or tracked objects) and plot over pullback
data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> – </p></li>
<li><p><strong>Options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>image sequence of RGB overlays</em></p></li>
<li><p><em>NPMitchell 2021</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.visualizeSegmentationPatch">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">visualizeSegmentationPatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">Options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.visualizeSegmentationPatch" title="Permalink to this definition">#</a></dt>
<dd><p>visualizeSegmentationPatch(QS, Options)
Load demo tracks (segmented or tracked objects) and plot over pullback
data from small patches of the surface mapped to the plane and
registered.</p>
<p>Todo: allow for pathline points near periodic boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>QS</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">QuapSlap</span> <span class="pre">class</span> <span class="pre">instance</span></code></span>) – </p></li>
<li><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">optional</span> <span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>coordSys : str specifier
timePoints : int array</p>
<blockquote>
<div><p>timepoints to visualize, must have segmentation for these
timepoints</p>
</div></blockquote>
<dl class="simple">
<dt>t0<span class="classifier">int</span></dt><dd><p>reference timepoint to convert to t=0 for timestamp</p>
</dd>
<dt>t0Pathlines<span class="classifier">int</span></dt><dd><p>timepoint at which pathlines form grid in pullback coords</p>
</dd>
</dl>
<p>overwrite : bool
buffer : float or int or numeric
bufferX : float or int or numeric, trumps buffer for X dim
bufferY : float or int or numeric, trumps buffer for Y dim
preview : preview (default=false)
scaleByMetric : bool (default=false)</p>
<blockquote>
<div><dl class="simple">
<dt>rescale parameterization to have det(g) approx 1 on either:</dt><dd><ul>
<li><p>faces queried by pts (if both imW and imH are not supplied)</p></li>
<li><p>in window com(pts) +/- [imW*0.5, imH*0.5]</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>scaleByMetricComponents<span class="classifier">bool (default=true)</span></dt><dd><p>rescale parameterization to approximate isothermal coordinates</p>
</dd>
<dt>imW<span class="classifier">int or numeric (default=25)</span></dt><dd><p>halfwidth of output image in QS.spaceUnits (approx)
(in units of quasi-embedding space –&gt; ie registered/flattened
embedding submesh units, should be close to units of QS.spaceUnits if
submesh is not too strongly curved in embedding space).</p>
</dd>
<dt>imH<span class="classifier">int or numeric (default=25)</span></dt><dd><p>halfheight of output image in QS.spaceUnits (approx)
(in units of quasi-embedding space –&gt; ie registered/flattened
embedding submesh units, should be close to units of QS.spaceUnits if
submesh is not too strongly curved in embedding space).</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>&lt;none&gt;</em></p></li>
<li><p><em>Saves to disk</em></p></li>
<li><p><em>————-</em></p></li>
<li><p><em>image sequence of RGB overlays</em></p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#@TubULAR.computeLocalSurfacePatch" title="@TubULAR.computeLocalSurfacePatch"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">computeLocalSurfacePatch</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">pts</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <a class="reference internal" href="#@TubULAR.visualizeDemoTracks" title="@TubULAR.visualizeDemoTracks"><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">visualizeDemoTracks</span></code></a>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">options</span></code>, <code class="xref mat mat-obj docutils literal notranslate"><span class="pre">NPMitchell</span></code></p>
</div>
</dd></dl>
<dl class="mat function">
<dt class="sig sig-object mat" id="@TubULAR.visualizeTracking3D">
<span class="sig-prename descclassname"><span class="pre">@TubULAR.</span></span><span class="sig-name descname"><span class="pre">visualizeTracking3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">QS</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#@TubULAR.visualizeTracking3D" title="Permalink to this definition">#</a></dt>
<dd><p>Draw cell contours (if method == segmentation) or nuclear track points
(if method == nuclei) and possibly connections between pairs of cells (if
drawGeodesics == true) in 3D on top of texturePatch image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">struct</span> <span class="pre">with</span> <span class="pre">fields</span></code></span>) – <p>timePoints : timepoints to visualize
method : ‘segmentation’ or ‘nuclei’
subdir : ‘labeled_groundTruth’
selectPairs : int (default=0 for no pair selection)</p>
<blockquote>
<div><p>number of cell pairs to select from segmentation for tracking.
Selection occurs at t=t0.</p>
</div></blockquote>
<p>drawGeodesics : bool
geodesicStyle : ‘pullback’ or ‘geodesic’</p>
<blockquote>
<div><p>’pullback’ draws a curve in 3d that connects the 2d segmentation pts
as straight line in pullback space projected into 3d
‘geodesic’ computes geodesic pairs on the surface using CGAL</p>
</div></blockquote>
<dl class="simple">
<dt>pairColors<span class="classifier">selectPairs x 1 cell array</span></dt><dd><p>selectPairs x 1 cell array of colors (either string
specifiers or 3x1 float array colors with values between 0-1.0)
pairColors{ii} is the color for the pair path connecting tracked
cells in pairIDs(ii, :)</p>
</dd>
<dt>viewAngles<span class="classifier">[-20,20] is default</span></dt><dd><p>must match texturePatch angles for overlays to be accurate</p>
</dd>
</dl>
<p>t0forPairs : timepoint at which we select which pairs to visualize
overlayStyle : ‘mask’, ‘add’</p>
<blockquote>
<div><p>whether to add or mask the segmentation/tracking/geodesics over the
texturePatch image</p>
</div></blockquote>
<dl class="simple">
<dt>lw_geoP<span class="classifier">float or int</span></dt><dd><p>linewidth for the geodesic paths</p>
</dd>
<dt>roiColor<span class="classifier">string specifier for color or 3x1 float between 0-1.0</span></dt><dd><p>color for the rectangular ROI boundary</p>
</dd>
<dt>overwriteROI<span class="classifier">bool</span></dt><dd><p>if the ROI polygon (projected rectangle at t0) exists on disk,
overwrite it with a newly calculated ROI</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">#</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="DEC.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">DEC is a Discrete Exterior Calculus toolbox for MATLAB.</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="example_usage_tubular_with_imsane.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Example for using TubULAR after making an ImSAnE experiment instance</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Noah P Mitchell and Dillon J Cislo
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">TubULAR</a></li>
<li><a class="reference internal" href="#coordinate-systems">Coordinate Systems</a></li>
<li><a class="reference internal" href="#apdv-coordinate-system-and-centerline-specification">APDV coordinate system and Centerline specification</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#module-&#64;TubULAR">Full Contents:</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    </body>
</html>