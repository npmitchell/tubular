<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Example for using TubULAR methods within ImSAnE" href="example_usage_imsane_with_tubular.html" /><link rel="prev" title="Example for using TubULAR just for surface visualization" href="example_usage_tubular_for_surface_visualization.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.03.04"/>
        <title>Example for using TubULAR: zebrafish heart dynamics - TubULAR 2022 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=935aa2abcc5c1da4283d1dc201fb1f0add16d23a" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=25ceb02ed1c46dc30f2321ff83e92799f69dfdb9" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">TubULAR 2022 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">TubULAR 2022 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="faq_debugging.html">Common issues in TubULAR and suggestions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_gutSample.html">Example for using TubULAR: midgut data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular.html">Example for using TubULAR: synthetic data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_for_surface_visualization.html">Example for using TubULAR just for surface visualization</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Example for using TubULAR: zebrafish heart dynamics</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="faq_debugging.html">Common issues in TubULAR and suggestions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_imsane_with_tubular.html">Example for using TubULAR methods within ImSAnE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_usage_tubular_with_imsane.html">Example for using TubULAR after making an ImSAnE experiment instance</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Principal contents:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="TubULAR.html">TubULAR</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TubULAR.html#coordinate-systems">Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="TubULAR.html#apdv-coordinate-system-and-centerline-specification">APDV coordinate system and Centerline specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="TubULAR.html#properties">Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="TubULAR.html#module-@TubULAR">Full Contents:</a></li>
<li class="toctree-l1"><a class="reference internal" href="TubULAR.html#indices-and-tables">Indices and tables</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="DEC.html">DEC is a Discrete Exterior Calculus toolbox for MATLAB.</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="example_DEC_diskMesh.html">Example for analyzing flow on a planar surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_DEC_sphericalMesh.html">Example for analyzing flow on a spherical surface</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container"><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="example-for-using-tubular-zebrafish-heart-dynamics">
<h1>Example for using TubULAR: zebrafish heart dynamics<a class="headerlink" href="#example-for-using-tubular-zebrafish-heart-dynamics" title="Permalink to this headline">#</a></h1>
<p>Here is an example for processing the zebrafish heart as in Figures 4-5 of the publicationâ€™s main text.
Note that this pipeline runs essentially all optional features along the way and also highlights an alternative method for capturing the organ surfaces, which is described in the supplementary information of the publication.</p>
<p>The analysis output of this pipeline is available here:
Mitchell, Noah; Cislo, Dillon (2022): Analysis of beating zebrafish heart. figshare. Dataset. <a class="reference external" href="https://doi.org/10.6084/m9.figshare.20670105">https://doi.org/10.6084/m9.figshare.20670105</a></p>
<p>All example datasets and analysis output for this codebase are availble in the collection here:
<a class="reference external" href="https://doi.org/10.6084/m9.figshare.c.6178351">https://doi.org/10.6084/m9.figshare.c.6178351</a></p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">%% TubULAR Analysis Pipeline: Zebrafish Heart (3D + time)</span><span class="w"></span>
<span class="c">% by NPMitchell and Dillon Cislo</span><span class="w"></span>

<span class="c">% This is a pipeline to analyize the dynamic tube-like surface of a growing</span><span class="w"></span>
<span class="c">% zebrafish heart in (3+1)D. During the developmental stage at which this</span><span class="w"></span>
<span class="c">% data was procured, the zebrafish heart is a tube with cylindrical</span><span class="w"></span>
<span class="c">% topology. Our surface extraction technology, however, renderes the fitted</span><span class="w"></span>
<span class="c">% surfaces as elongated and spherical in topology. This pipeline will</span><span class="w"></span>
<span class="c">% demonstarate:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% (1) How to restore the cylindrical topology by the removal of 'endcaps'</span><span class="w"></span>
<span class="c">% (2) How to slice open and unwrap the tube-like surface into the plane</span><span class="w"></span>
<span class="c">% (3) How to construct time-dependent 'surface Lagrangian' coordinates</span><span class="w"></span>
<span class="c">% (4) How to apply the DEC to analyze flow on the shape-shifting surface</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% TODO:</span><span class="w"></span>
<span class="c">%   - WE REALLY NEED THE EXPERIMENT METADATA (time interval, space units</span><span class="w"></span>
<span class="c">%   etc.)</span><span class="w"></span>
<span class="c">%   - Your axis order choices are crap</span><span class="w"></span>
<span class="c">%   - Should probably just make a new MeshLab script that would deprecate</span><span class="w"></span>
<span class="c">%   the mesh simplification step post surface detection</span><span class="w"></span>

<span class="c">% Add necessary directories to the path</span><span class="w"></span>
<span class="n">tubularDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'/mnt/data/code/tubular'</span><span class="p">;</span><span class="w"></span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="n">tubularDir</span><span class="p">));</span><span class="w"></span>

<span class="c">% Add optional external code to the path</span><span class="w"></span>
<span class="c">% rmpath(genpath('mnt/data/code/gptooolbox'));</span><span class="w"></span>
<span class="c">% addpath(genpath('/mnt/data/code/gptoolbox'));</span><span class="w"></span>

<span class="c">%% TubULAR Pipeline Initialization ========================================</span><span class="w"></span>

<span class="c">% We start by clearing the memory and closing all figures</span><span class="w"></span>
<span class="nb">clear</span><span class="p">;</span><span class="w"> </span><span class="n">close</span><span class="w"> </span><span class="s">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="c">% The directory containing the zebrafish heart data</span><span class="w"></span>
<span class="n">dataDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'/mnt/data/tubular_test/zebrafish_heart/'</span><span class="p">;</span><span class="w"></span>

<span class="c">% The directory where project files will be generated and saved</span><span class="w"></span>
<span class="n">projectDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="n">dataDir</span><span class="p">,</span><span class="w"> </span><span class="s">'analysis'</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="c">% [projectDir, ~, ~] = fileparts(matlab.desktop.editor.getActiveFilename);</span><span class="w"></span>
<span class="nb">cd</span><span class="p">(</span><span class="n">projectDir</span><span class="p">);</span><span class="w"></span>

<span class="c">% Define TubULAR master settings</span><span class="w"></span>
<span class="n">overwriteSettings</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'masterSettings.mat'</span><span class="p">),</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">overwriteSettings</span><span class="p">)</span><span class="w"></span>

<span class="n">stackResolution</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mf">.3524</span><span class="w"> </span><span class="mf">.3524</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w">  </span><span class="c">% resolution in spaceUnits per pixel</span><span class="w"></span>
<span class="n">nChannels</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                      </span><span class="c">% how many channels is the data (ex 2 for GFP + RFP)</span><span class="w"></span>
<span class="n">channelsUsed</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                   </span><span class="c">% which channels are used for analysis</span><span class="w"></span>
<span class="n">timePoints</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">30</span><span class="p">;</span><span class="w"> </span><span class="c">% 1:50;          % timepoints to include in the analysis</span><span class="w"></span>
<span class="n">ssfactor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">                       </span><span class="c">% subsampling factor</span><span class="w"></span>
<span class="n">flipy</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w">                     </span><span class="c">% whether the data is stored inverted relative to real position in lab frame</span><span class="w"></span>
<span class="n">timeInterval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                   </span><span class="c">% physical interval between timepoints</span><span class="w"></span>
<span class="n">timeUnits</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'min'</span><span class="p">;</span><span class="w">                  </span><span class="c">% physical unit of time between timepoints</span><span class="w"></span>
<span class="n">spaceUnits</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'$\mu$m'</span><span class="p">;</span><span class="w">              </span><span class="c">% physical unit of time between timepoints</span><span class="w"></span>
<span class="n">fn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'Stack_Repeat_014_Time_%03d'</span><span class="p">;</span><span class="w">      </span><span class="c">% filename string pattern</span><span class="w"></span>
<span class="n">set_preilastikaxisorder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'xyzc'</span><span class="p">;</span><span class="w">       </span><span class="c">% data axis order for subsampled h5 data (ilastik input)</span><span class="w"></span>
<span class="n">swapZT</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">                      </span><span class="c">% whether to swap the z and t dimensions</span><span class="w"></span>

<span class="n">masterSettings</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">(</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'stackResolution'</span><span class="p">,</span><span class="w"> </span><span class="n">stackResolution</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'nChannels'</span><span class="p">,</span><span class="w"> </span><span class="n">nChannels</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'channelsUsed'</span><span class="p">,</span><span class="w"> </span><span class="n">channelsUsed</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'timePoints'</span><span class="p">,</span><span class="w"> </span><span class="n">timePoints</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'ssfactor'</span><span class="p">,</span><span class="w"> </span><span class="n">ssfactor</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'flipy'</span><span class="p">,</span><span class="w"> </span><span class="n">flipy</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'timeInterval'</span><span class="p">,</span><span class="w"> </span><span class="n">timeInterval</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'timeUnits'</span><span class="p">,</span><span class="w"> </span><span class="n">timeUnits</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'spaceUnits'</span><span class="p">,</span><span class="w"> </span><span class="n">spaceUnits</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'fn'</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="k">...</span><span class="w"></span>
<span class="s">'swapZT'</span><span class="p">,</span><span class="w"> </span><span class="n">swapZT</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'set_preilastikaxisorder'</span><span class="p">,</span><span class="w"> </span><span class="n">set_preilastikaxisorder</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'nU'</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'nV'</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="nb">disp</span><span class="p">([</span><span class="s">'Saving master settings to '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'masterSettings.mat'</span><span class="p">)]);</span><span class="w"></span>

<span class="nb">save</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'masterSettings.mat'</span><span class="p">),</span><span class="w"> </span><span class="s">'masterSettings'</span><span class="p">);</span><span class="w"></span>

<span class="n">clear</span><span class="w"> </span><span class="s">stackResolution</span><span class="w"> </span><span class="s">nChannels</span><span class="w"> </span><span class="s">channelsUsed</span><span class="w"> </span><span class="s">timePoints</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">ssfactor</span><span class="w"> </span><span class="n">flipy</span><span class="w"> </span><span class="n">timeInterval</span><span class="w"> </span><span class="n">timeUnits</span><span class="w"> </span><span class="n">spaceUnits</span><span class="w"> </span><span class="n">fn</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">set_preilastikaxisorder</span><span class="w"> </span><span class="n">swapZT</span><span class="w"></span>

<span class="nb">disp</span><span class="p">(</span><span class="s">'Saving masterSettings to ./masterSettings.mat'</span><span class="p">)</span><span class="w"></span>

<span class="k">else</span><span class="w"></span>

<span class="nb">disp</span><span class="p">([</span><span class="s">'Loading master settings from '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'masterSettings.mat'</span><span class="p">)]);</span><span class="w"></span>

<span class="nb">load</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'masterSettings.mat'</span><span class="p">),</span><span class="w"> </span><span class="s">'masterSettings'</span><span class="p">);</span><span class="w"></span>


<span class="k">end</span><span class="w"></span>

<span class="c">%% ************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">%      PART 1: SURFACE DETECTION USING ImSAnE's 'integralDetector'</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>

<span class="c">% Add ImSAnE to the path</span><span class="w"></span>
<span class="nb">addpath</span><span class="p">(</span><span class="nb">genpath</span><span class="p">(</span><span class="s">'/mnt/data/code/imsane_for_git/imsane'</span><span class="p">));</span><span class="w"></span>
<span class="nb">rmpath</span><span class="p">(</span><span class="s">'/mnt/data/code/imsane_for_git/imsane/external/CGAL_Code/IsotropicRemeshing'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Initialize ImSAnE Project ==============================================</span><span class="w"></span>

<span class="c">% We start by creating the experiment object, which holds the project</span><span class="w"></span>
<span class="c">% metadata and serves as a front-end for a number of tasks, including data</span><span class="w"></span>
<span class="c">% loading, detection, fitting, etc.  When instantiating the experiment</span><span class="w"></span>
<span class="c">% object we must indicate the path of the project directory and the data</span><span class="w"></span>
<span class="c">% directory, either by passing them as arguments to the constructor or by</span><span class="w"></span>
<span class="c">% picking them manually from a dialog box</span><span class="w"></span>

<span class="n">xp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">project</span><span class="p">.</span><span class="n">Experiment</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="n">dataDir</span><span class="p">);</span><span class="w"></span>

<span class="c">% Set File Metadata -------------------------------------------------------</span><span class="w"></span>
<span class="c">% First we set the metadata pertaining to the raw data files in the</span><span class="w"></span>
<span class="c">% structure 'fileMeta'.  ImSAnE assumes that individual time points are</span><span class="w"></span>
<span class="c">% saved as separate image stacks and that filenames in a time series are</span><span class="w"></span>
<span class="c">% identical up to a integer specifying the timepoint.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% The following file metadata information is required:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% * 'directory'         , the project directory (full path)</span><span class="w"></span>
<span class="c">% * 'dataDir'           , the data directory (full path)</span><span class="w"></span>
<span class="c">% * 'filenameFormat'    , fprintf type format spec of file name</span><span class="w"></span>
<span class="c">% * 'timePoints'        , list of times available stored as a vector</span><span class="w"></span>
<span class="c">% * 'stackResolution'   , stack resolution in microns, e.g. [0.25 0.25 1]</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% The following file metadata information is optional:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% * 'imageSpace'        , bit depth of image, such as uint16 etc., defined</span><span class="w"></span>
<span class="c">%                         in Stack class</span><span class="w"></span>
<span class="c">% * 'stackSize'         , size of stack in pixels per dimension</span><span class="w"></span>
<span class="c">%                         [xSize ySize zSize]</span><span class="w"></span>
<span class="c">% * 'swapZT'            , set=1 if time is 3rd dimension and z is 4th</span><span class="w"></span>
<span class="c">% * 'nChannels'         , The number of channels in the raw data</span><span class="w"></span>

<span class="n">fileMeta</span><span class="w">                    </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">dataDir</span><span class="w">            </span><span class="p">=</span><span class="w"> </span><span class="n">dataDir</span><span class="p">;</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">filenameFormat</span><span class="w">     </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="s">'.tif'</span><span class="w"> </span><span class="p">];</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">nChannels</span><span class="w">          </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">nChannels</span><span class="p">;</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">timePoints</span><span class="p">;</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">stackResolution</span><span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">stackResolution</span><span class="p">;</span><span class="w"></span>
<span class="n">fileMeta</span><span class="p">.</span><span class="n">swapZT</span><span class="w">             </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">swapZT</span><span class="p">;</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setFileMeta</span><span class="p">(</span><span class="n">fileMeta</span><span class="p">);</span><span class="w"></span>

<span class="c">% Set Experiment Metadata -------------------------------------------------</span><span class="w"></span>
<span class="c">% Next we set additional information regarding our experiment as fields in</span><span class="w"></span>
<span class="c">% the 'expMeta' structure.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% The following project metadata information is required:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% * 'channelsUsed'      , the channels used, e.g. [1 3] for RGB</span><span class="w"></span>
<span class="c">% * 'channelColor'      , mapping from element in channels used to RGB=123</span><span class="w"></span>
<span class="c">% * 'dynamicSurface'    , Boolean, false: static surface</span><span class="w"></span>
<span class="c">% * 'detectorType'      , name of detector class</span><span class="w"></span>
<span class="c">% * 'fitterType'        , name of fitter class</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% The following project meta data information is optional:</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% * 'description'     , string describing the data set</span><span class="w"></span>
<span class="c">% * 'jitterCorrection', Boolean, false: No fft based jitter correction</span><span class="w"></span>

<span class="n">expMeta</span><span class="w">                     </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">channelsUsed</span><span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">channelsUsed</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">channelColor</span><span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">description</span><span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="s">'A beating Zebrafish heart'</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">dynamicSurface</span><span class="w">      </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">jitterCorrection</span><span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">fitTime</span><span class="w">             </span><span class="p">=</span><span class="w"> </span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">detectorType</span><span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="s">'surfaceDetection.morphsnakesDetector'</span><span class="p">;</span><span class="w"></span>
<span class="n">expMeta</span><span class="p">.</span><span class="n">fitterType</span><span class="w">          </span><span class="p">=</span><span class="w"> </span><span class="s">'surfaceFitting.meshWrapper'</span><span class="p">;</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setExpMeta</span><span class="p">(</span><span class="n">expMeta</span><span class="p">);</span><span class="w"></span>

<span class="c">% Initialize New Experiment -----------------------------------------------</span><span class="w"></span>
<span class="c">% Finally we call initNew(), which reads the stack size from the first</span><span class="w"></span>
<span class="c">% available time point, then initializes fitter and detector and creates</span><span class="w"></span>
<span class="c">% fitOptions and detectOptions based on their defaults.</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">initNew</span><span class="p">();</span><span class="w"></span>

<span class="n">clear</span><span class="w"> </span><span class="s">fileMeta</span><span class="w"> </span><span class="s">expMeta</span><span class="w"></span>

<span class="c">%% Load First Time Point ==================================================</span><span class="w"></span>
<span class="c">% First we load the data for the fittingtime point. This is not necessary</span><span class="w"></span>
<span class="c">% for surface detection. However, it is required to properly store</span><span class="w"></span>
<span class="c">% information generated in subsequent steps (i.e. generating the surface of</span><span class="w"></span>
<span class="c">% interest object) and we might as well get it out of the way now and also</span><span class="w"></span>
<span class="c">% demonstrate some visualization functionality offered by ImSAnE</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">loadTime</span><span class="p">(</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">expMeta</span><span class="p">.</span><span class="n">fitTime</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">rescaleStackToUnitAspect</span><span class="p">();</span><span class="w"></span>

<span class="c">% The data in xp.stack is stored as a 'Stack' object. The easiest way</span><span class="w"></span>
<span class="c">% to look at a cross section of the data is using getSlice</span><span class="w"></span>

<span class="c">% imshow( xp.stack.getSlice( 'z', 90 ), [] );</span><span class="w"></span>

<span class="c">%% Set Surface Detection Objects ==========================================</span><span class="w"></span>
<span class="c">% We now attempt to detect the surface of interest.  In this pipeline, we</span><span class="w"></span>
<span class="c">% use the 'integralDetector'.  This detector is essentially a wrapper for</span><span class="w"></span>
<span class="c">% the morphological snakes external code module.  The input to this module</span><span class="w"></span>
<span class="c">% is a sub-sampled Ilastik pixel probability map.  Given this map, the</span><span class="w"></span>
<span class="c">% method attempts to segmemt the image volume into distinct regions by</span><span class="w"></span>
<span class="c">% minimizing the following (schematic) energy functional</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% Etot = Est + Ep + Ein + Eout</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% Est amounts to a surface tension, Ep amounts to a pressure, Ein tries to</span><span class="w"></span>
<span class="c">% make all voxels inside the segmented region have similar intensities, and</span><span class="w"></span>
<span class="c">% Eout tries to make all of the voxels outside the segmented region have</span><span class="w"></span>
<span class="c">% similar intensities. It is assumed that the region of interest is a</span><span class="w"></span>
<span class="c">% closed volume.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% See ImSAnE's 'surfaceDetection.integralDetector' for option documentation</span><span class="w"></span>

<span class="n">msls_detOpts_fn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'msls_detectOpts.mat'</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">exist</span><span class="p">(</span><span class="n">msls_detOpts_fn</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>

<span class="nb">load</span><span class="p">(</span><span class="n">msls_detOpts_fn</span><span class="p">,</span><span class="w"> </span><span class="s">'detectOptions'</span><span class="p">);</span><span class="w"></span>

<span class="k">else</span><span class="w"></span>

<span class="c">% The name of the meshlab script that generates a mesh from the point</span><span class="w"></span>
<span class="c">% cloud</span><span class="w"></span>
<span class="n">mlxprogram</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'laplace_surface_rm_resample30k_reconstruct_LS3_1p2pc_ssfactor4.mlx'</span><span class="p">;</span><span class="w"></span>
<span class="n">mlxprogram</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="s">'/mnt/data/code/meshlab_codes/'</span><span class="p">,</span><span class="w"> </span><span class="n">mlxprogram</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="n">detectOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">channel</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">channelsUsed</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ssfactor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">ssfactor</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">niter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">niter0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">400</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">lambda1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">lambda2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">pressure</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">tension</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">pre_pressure</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">pre_tension</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">post_pressure</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">post_tension</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">exit_thres</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">foreGroundChannel</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">channelsUsed</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">fileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">expMeta</span><span class="p">.</span><span class="n">fitTime</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">mslsDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'MorphSnakesOutput'</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ofn_ls</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'msls_DP_'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ofn_ply</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'mesh_DP_ms_'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ms_scriptDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'/mnt/data/code/morphsnakes_wrapper/morphsnakes_wrapper'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">timepoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">expMeta</span><span class="p">.</span><span class="n">fitTime</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">zdim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ofn_smoothply</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'mesh_DP_'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">mlxprogram</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="n">mlxprogram</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">init_ls_fn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'empty_string'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">run_full_dataset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">radius_guess</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">dset_name</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'exported_data'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">center_guess</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'30,125,125'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">plot_mesh3d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">dtype</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'h5'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'none'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">mesh_from_pointcloud</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">prob_searchstr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'_Probabilities.h5'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">preilastikaxisorder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">set_preilastikaxisorder</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ilastikaxisorder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'cxyz'</span><span class="p">;</span><span class="w"> </span><span class="c">%'cxyz';</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">physicalaxisorder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'yxzc'</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">include_boundary_faces</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">smooth_with_matlab</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">pythonVersion</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">''</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setDetectOptions</span><span class="p">(</span><span class="w"> </span><span class="n">detectOptions</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">%% Batch Ilastik Pre-Processing ===========================================</span><span class="w"></span>
<span class="c">% In this section we load the formatted time series data and render the</span><span class="w"></span>
<span class="c">% .tif files into sub-sampled .h5 files appropriate for segmentation in</span><span class="w"></span>
<span class="c">% Ilastik</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% -------------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% NOTE: This section is slow - it requires us to load and format the raw</span><span class="w"></span>
<span class="c">% data stack of each individual time point.  If you are just following</span><span class="w"></span>
<span class="c">% along with the tutorial, skip this section - it has already been done for</span><span class="w"></span>
<span class="c">% you!</span><span class="w"></span>
<span class="c">%--------------------------------------------------------------------------</span><span class="w"></span>

<span class="c">% Create the directory that will hold the Ilastik prep files</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'prepFiles'</span><span class="p">),</span><span class="w"> </span><span class="s">'dir'</span><span class="p">)</span><span class="w"></span>
<span class="nb">mkdir</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'prepFiles'</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="w"></span>

<span class="n">prepFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">'prepFiles/'</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">masterSettings</span><span class="p">.</span><span class="n">fn</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">prepFileName</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">loadTime</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">rescaleStackToUnitAspect</span><span class="p">();</span><span class="w"></span>

<span class="n">detectOptions</span><span class="p">.</span><span class="n">fileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">prepFileName</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">timepoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">;</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setDetectOptions</span><span class="p">(</span><span class="n">detectOptions</span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">detector</span><span class="p">.</span><span class="n">prepareIlastik</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">prepFileName</span><span class="w"></span>

<span class="c">%% Batch Creation of Ilastik Prediction ===================================</span><span class="w"></span>
<span class="c">% At this point the user should switch to Ilastik and train to create a</span><span class="w"></span>
<span class="c">% pixel probability map using the sub-sampled prep files.  Don't work too</span><span class="w"></span>
<span class="c">% hard here! You dont have to train on every single time point.  Training</span><span class="w"></span>
<span class="c">% can be performed on a subset of the time series (or even on a single time</span><span class="w"></span>
<span class="c">% point if you're bold) and used to batch process the rest!</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% The rest of this pipeline assumes that the pixel probability maps are</span><span class="w"></span>
<span class="c">% stored in a folder 'projectDir/probFiles'.  Make sure to set the export</span><span class="w"></span>
<span class="c">% preferences in Ilastik accordingly!</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'probFiles'</span><span class="p">),</span><span class="w"> </span><span class="s">'dir'</span><span class="p">)</span><span class="w"></span>
<span class="nb">mkdir</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'probFiles'</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">%--------------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% NOTE: This section is slow - it requires us to complete an Ilastik</span><span class="w"></span>
<span class="c">% training workflow and batch process each time point in the data set.  If</span><span class="w"></span>
<span class="c">% you are just following along with the tutorial, skip this section - it</span><span class="w"></span>
<span class="c">% has already been done for you!</span><span class="w"></span>
<span class="c">%--------------------------------------------------------------------------</span><span class="w"></span>

<span class="c">%% Create MorphSnakes Level Sets from Ilastik Probabilities Output ========</span><span class="w"></span>

<span class="c">% Detect the Surface at the First Time Point ------------------------------</span><span class="w"></span>

<span class="c">% The name of the probability file used for detection</span><span class="w"></span>
<span class="n">probFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">'probFiles/'</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">fn</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Update detector options</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">fileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">probFileName</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">timepoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setDetectOptions</span><span class="p">(</span><span class="w"> </span><span class="n">detectOptions</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Calling detectSurface() runs the morphsnakes detection protocol</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">detectSurface</span><span class="p">()</span><span class="w"></span>

<span class="c">% Detect the Surfaces at all Subsequent Time Points -----------------------</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="w"></span>

<span class="n">tidx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">tIdx</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="c">% The name of the probability file used for detection</span><span class="w"></span>
<span class="n">probFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">'probFiles/'</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">fn</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Update detector options</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">fileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">probFileName</span><span class="p">;</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">timepoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>

<span class="c">% Use the previous time points surface as an initial guess</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">init_ls_fn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">([</span><span class="n">detectOptions</span><span class="p">.</span><span class="n">ofn_ls</span><span class="w"> </span><span class="s">'%06d.h5'</span><span class="p">],</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="n">tidx</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="n">xp</span><span class="p">.</span><span class="n">setDetectOptions</span><span class="p">(</span><span class="w"> </span><span class="n">detectOptions</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Calling detectSurface() runs the morphsnakes detection protocol</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">detectSurface</span><span class="p">();</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">probFileName</span><span class="w"></span>

<span class="c">%% Generate Point Cloud/Mesh from Level Set ===============================</span><span class="w"></span>
<span class="c">% This section extracts a simplied point set from the volumetric level set</span><span class="w"></span>
<span class="c">% corresponding to the cylindrical surface of the heart and then constructs</span><span class="w"></span>
<span class="c">% a watertight mesh using Poisson surface reconstruction. The</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="c">% Create a directory to hold the output point cloud files</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'objFiles'</span><span class="p">),</span><span class="s">'dir'</span><span class="p">)</span><span class="w"></span>
<span class="nb">mkdir</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'objFiles'</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Create a directory to hold the output mesh files</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'meshFiles'</span><span class="p">),</span><span class="s">'dir'</span><span class="p">)</span><span class="w"></span>
<span class="nb">mkdir</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'meshFiles'</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">()</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Now processing timepoint T=%d\n'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="n">pointCloudFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s">'objFiles/pointCloud_T%03d.obj'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="n">meshFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s">'meshFiles/mesh_T%03d.off'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">pointCloudFileName</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Extract the implicit level set as a 3D binary array</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="c">% The file name of the current time point</span><span class="w"></span>
<span class="n">implicitLSFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">detectOptions</span><span class="p">.</span><span class="n">mslsDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="s">'msls_DP_%06d.h5'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% The 3D binary array</span><span class="w"></span>
<span class="n">bwLS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">h5read</span><span class="p">(</span><span class="w"> </span><span class="n">implicitLSFile</span><span class="p">,</span><span class="w"> </span><span class="s">'/implicit_levelset'</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Keep only the largest connected component from the implicit</span><span class="w"></span>
<span class="c">% levelset</span><span class="w"></span>
<span class="n">bwCC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bwconncomp</span><span class="p">(</span><span class="n">bwLS</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">maxID</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="nb">cellfun</span><span class="p">(@</span><span class="nb">numel</span><span class="p">,</span><span class="w"> </span><span class="n">bwCC</span><span class="p">.</span><span class="n">PixelIdxList</span><span class="p">));</span><span class="w"></span>
<span class="n">bwLS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">bwLS</span><span class="p">));</span><span class="w"></span>
<span class="n">bwLS</span><span class="p">(</span><span class="n">bwCC</span><span class="p">.</span><span class="n">PixelIdxList</span><span class="p">{</span><span class="n">maxID</span><span class="p">})</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="c">% Fill in holes in the volume</span><span class="w"></span>
<span class="n">bwLS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">imfill</span><span class="p">(</span><span class="w"> </span><span class="n">bwLS</span><span class="p">,</span><span class="w"> </span><span class="s">'holes'</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Re-assess level set quality</span><span class="w"></span>
<span class="n">bwCC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bwconncomp</span><span class="p">(</span><span class="n">bwLS</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">bwCC</span><span class="p">.</span><span class="n">NumObjects</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="nb">warning</span><span class="p">(</span><span class="s">'Level set is multiply connected!'</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="n">bwCC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bwconncomp</span><span class="p">(</span><span class="o">~</span><span class="n">bwLS</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">bwCC</span><span class="p">.</span><span class="n">NumObjects</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="nb">warning</span><span class="p">(</span><span class="w"> </span><span class="s">'Level set complement is multiply connected!'</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Skeletonize each cross section of the binary volume to produce a</span><span class="w"></span>
<span class="c">% minimal point set</span><span class="w"></span>
<span class="n">bwLS0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">permute</span><span class="p">(</span><span class="n">bwLS</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="n">bwLS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">bwLS0</span><span class="p">));</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">bwLS</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="n">progressbar</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="nb">size</span><span class="p">(</span><span class="n">bwLS</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">bwLS</span><span class="p">(:,:,</span><span class="nb">i</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bwskel</span><span class="p">(</span><span class="n">bwLS0</span><span class="p">(:,:,</span><span class="nb">i</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
<span class="n">bwCC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bwconncomp</span><span class="p">(</span><span class="n">bwLS</span><span class="p">);</span><span class="w"></span>

<span class="c">% Extract the (x,y,z)-locations of the level set points</span><span class="w"></span>
<span class="c">% (in pixel space)</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="p">[</span><span class="w"> </span><span class="n">P</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">P</span><span class="p">(:,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">P</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">ind2sub</span><span class="p">(</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">bwLS</span><span class="p">),</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">vertcat</span><span class="p">(</span><span class="n">bwCC</span><span class="p">.</span><span class="n">PixelIdxList</span><span class="p">{:})</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Rescale boundary pixel locations to the size of the image stack</span><span class="w"></span>
<span class="n">P</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">detectOptions</span><span class="p">.</span><span class="n">ssfactor</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="c">% Downsample/denoise the point set</span><span class="w"></span>
<span class="n">PC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">pointCloud</span><span class="p">(</span><span class="n">P</span><span class="p">);</span><span class="w"></span>
<span class="n">PC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">pcdownsample</span><span class="p">(</span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="s">'nonuniformGridSample'</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">);</span><span class="w"> </span><span class="c">%150</span><span class="w"></span>
<span class="c">% PC = pcdenoise(PC, 'NumNeighbors', 24, 'Threshold', 2.5); % 24</span><span class="w"></span>
<span class="n">P</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">PC</span><span class="p">.</span><span class="n">Location</span><span class="p">;</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Number of points = %d\n'</span><span class="p">,</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Estimate Point Set Normals</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="n">param</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">param</span><span class="p">.</span><span class="n">estimation_procedure</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c">% Uses PCA normal estimation</span><span class="w"></span>
<span class="n">param</span><span class="p">.</span><span class="n">number_of_neighbors</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">18</span><span class="p">;</span><span class="w"></span>
<span class="n">orient_neighbors</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>

<span class="c">% P0 = P;</span><span class="w"></span>
<span class="p">[</span><span class="w"> </span><span class="n">PN</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">oriented</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">point_set_normals</span><span class="p">(</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">orient_neighbors</span><span class="w"> </span><span class="s">)</span><span class="p">;</span><span class="w"></span>

<span class="c">% Check to see if any points were removed during normal orientation</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">oriented</span><span class="w"></span>
<span class="nb">warning</span><span class="p">([</span><span class="s">'Point set normal orientation procedure'</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'removed points from the input set!'</span><span class="p">]);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% View results ----------------------------------------------------</span><span class="w"></span>
<span class="c">% ssf = false( size(P,1), 1 );</span><span class="w"></span>
<span class="c">% sst = false( size(P,1), 1 );</span><span class="w"></span>
<span class="c">% sst(1:5:end) = true;</span><span class="w"></span>
<span class="c">% % sst = true( size(P, 1), 1 );</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% scatter3(  P([sst; ssf; ssf]), P([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     P([ssf; ssf; sst]), 'filled' );</span><span class="w"></span>
<span class="c">% hold on</span><span class="w"></span>
<span class="c">% quiver3( P([sst; ssf; ssf]), P([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     P([ssf; ssf; sst]), ...</span><span class="w"></span>
<span class="c">%     PN([sst; ssf; ssf]), PN([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     PN([ssf; ssf; sst]), ...</span><span class="w"></span>
<span class="c">%     1, 'LineWidth', 2 );</span><span class="w"></span>
<span class="c">% axis equal</span><span class="w"></span>
<span class="c">% hold off</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Upsample Point Set</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="n">numPoints</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3000</span><span class="p">;</span><span class="w"> </span><span class="c">% The number of output points</span><span class="w"></span>
<span class="n">sharpnessAngle</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">90</span><span class="p">;</span><span class="w"> </span><span class="c">% Controls the sharpness of the results</span><span class="w"></span>
<span class="n">edgeSensitvity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c">% Controls sampling density near inferred edges</span><span class="w"></span>
<span class="n">neighborRadius</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">eps</span><span class="p">;</span><span class="w"> </span><span class="c">% Initial neighbor radius</span><span class="w"></span>

<span class="p">[</span><span class="n">PU</span><span class="p">,</span><span class="w"> </span><span class="n">PNU</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">upsample_point_set</span><span class="p">(</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">PN</span><span class="p">,</span><span class="w"> </span><span class="n">numPoints</span><span class="p">,</span><span class="w"> </span><span class="n">sharpnessAngle</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">edgeSensitvity</span><span class="p">,</span><span class="w"> </span><span class="n">neighborRadius</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% View results ----------------------------------------------------</span><span class="w"></span>
<span class="c">% ssf = false( size(PU,1), 1 );</span><span class="w"></span>
<span class="c">% sst = true( size(PU, 1), 1 );</span><span class="w"></span>
<span class="c">% % sst = false( size(P,1), 1 );</span><span class="w"></span>
<span class="c">% % sst(1:50:end) = true;</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% scatter3(  PU([sst; ssf; ssf]), PU([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     PU([ssf; ssf; sst]), 'filled' );</span><span class="w"></span>
<span class="c">% hold on</span><span class="w"></span>
<span class="c">% quiver3( PU([sst; ssf; ssf]), PU([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     PU([ssf; ssf; sst]), ...</span><span class="w"></span>
<span class="c">%     PNU([sst; ssf; ssf]), PNU([ssf; sst; ssf]), ...</span><span class="w"></span>
<span class="c">%     PNU([ssf; ssf; sst]), ...</span><span class="w"></span>
<span class="c">%     1, 'LineWidth', 2 );</span><span class="w"></span>
<span class="c">% axis equal</span><span class="w"></span>
<span class="c">% hold off</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Output Point Cloud/Mesh Files</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="c">% Output point cloud file</span><span class="w"></span>
<span class="n">OBJ</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">OBJ</span><span class="p">.</span><span class="n">vertices</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">PU</span><span class="p">;</span><span class="w"></span>
<span class="n">OBJ</span><span class="p">.</span><span class="n">vertices_normal</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">PNU</span><span class="p">;</span><span class="w"></span>
<span class="n">OBJ</span><span class="p">.</span><span class="n">objects</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">type</span><span class="p">=</span><span class="s">'f'</span><span class="p">;</span><span class="w"></span>
<span class="n">OBJ</span><span class="p">.</span><span class="n">objects</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">data</span><span class="p">.</span><span class="n">vertices</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="n">OBJ</span><span class="p">.</span><span class="n">objects</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">data</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="n">write_wobj</span><span class="p">(</span><span class="n">OBJ</span><span class="p">,</span><span class="w"> </span><span class="n">pointCloudFileName</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="k">else</span><span class="w"></span>

<span class="c">% Read in point cloud from file</span><span class="w"></span>
<span class="p">[</span><span class="n">PU</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">PNU</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOBJ</span><span class="p">(</span><span class="n">pointCloudFileName</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">meshFileName</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Generate Mesh From Point Cloud</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="n">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">PU</span><span class="p">,</span><span class="w"> </span><span class="n">PNU</span><span class="p">,</span><span class="w"> </span><span class="s">'poisson_mesh.off'</span><span class="p">);</span><span class="w"></span>

<span class="c">% Read in result from file and delete original file</span><span class="w"></span>
<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOFF</span><span class="p">(</span><span class="s">'poisson_mesh.off'</span><span class="p">);</span><span class="w"></span>
<span class="nb">delete</span><span class="p">(</span><span class="s">'poisson_mesh.off'</span><span class="p">);</span><span class="w"></span>

<span class="c">% Clean mesh surface ----------------------------------------------</span><span class="w"></span>

<span class="c">% Isotropically remesh the surface</span><span class="w"></span>
<span class="n">tar_length</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="n">num_iter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="n">protect_constraints</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">isotropic_remeshing</span><span class="p">(</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">tar_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">,</span><span class="w"> </span><span class="n">protect_constraints</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="c">% Attempt to remove localized mesh spikes by Laplacian relaxation</span><span class="w"></span>
<span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">relax_mesh_spikes</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="nb">deg2rad</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span><span class="w"> </span><span class="nb">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'uniform'</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">'implicit'</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>

<span class="c">% Try to remove self-intersections</span><span class="w"></span>
<span class="p">[</span><span class="n">intersects</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">mesh_self_intersection_3d</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">);</span><span class="w"></span>
<span class="n">intCount</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="n">intersects</span><span class="w"></span>

<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">clean_mesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="s">'MinDist'</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">'MinArea'</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'MinAngle'</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">'SelfIntersections'</span><span class="p">,</span><span class="w"> </span><span class="s">'remove'</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'SmallTriangles'</span><span class="p">,</span><span class="w"> </span><span class="s">'remove'</span><span class="p">);</span><span class="w"></span>

<span class="c">% Peform a another isotropic remeshing</span><span class="w"></span>
<span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">isotropic_remeshing</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">tar_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">,</span><span class="w"> </span><span class="n">protect_constraints</span><span class="p">);</span><span class="w"></span>

<span class="c">% Another round of spike relaxation</span><span class="w"></span>
<span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">relax_mesh_spikes</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="nb">deg2rad</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span><span class="w"> </span><span class="nb">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'uniform'</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">'implicit'</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="n">intersects</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">mesh_self_intersection_3d</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">);</span><span class="w"></span>

<span class="n">intCount</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">intCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">intCount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">20</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="s">'Unable to remove self-intersections'</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="c">% Another round of isotropic remeshing</span><span class="w"></span>
<span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">isotropic_remeshing</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">tar_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">,</span><span class="w"> </span><span class="n">protect_constraints</span><span class="p">);</span><span class="w"></span>

<span class="c">% Smooth the entire mesh fixing the boundary</span><span class="w"></span>
<span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">laplacian_smooth</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="s">'cotan'</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="mf">0.025</span><span class="p">,</span><span class="w"> </span><span class="s">'implicit'</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>

<span class="c">% Peform a final isotropic remeshing</span><span class="w"></span>
<span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">isotropic_remeshing</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">tar_length</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">,</span><span class="w"> </span><span class="n">protect_constraints</span><span class="p">);</span><span class="w"></span>

<span class="c">% Mesh quality checks ---------------------------------------------</span><span class="w"></span>

<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">edges</span><span class="p">(</span><span class="nb">triangulation</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">));</span><span class="w"></span>

<span class="n">numBdy</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">DiscreteRicciFlow</span><span class="p">.</span><span class="n">compute_boundaries</span><span class="p">(</span><span class="n">F</span><span class="p">));</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numBdy</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="s">'Mesh at time point T = %d has %d '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'boundary components'</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">numBdy</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="n">eulerChi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eulerChi</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="s">'Mesh at time point T = %d is not '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'a topological sphere'</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="p">[</span><span class="n">intersects</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">mesh_self_intersection_3d</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">intersects</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="s">'Mesh at time point T = %d contains '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'self-intersections'</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% hold on</span><span class="w"></span>
<span class="c">% trisurf(triangulation(F, V), 'FaceColor', 0.8 * ones([1 3]));</span><span class="w"></span>
<span class="c">% hold off</span><span class="w"></span>

<span class="c">%------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Output Mesh Files</span><span class="w"></span>
<span class="c">%------------------------------------------------------------------</span><span class="w"></span>

<span class="n">writeOFF</span><span class="p">(</span><span class="n">meshFileName</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">pointCloudFileName</span><span class="w"> </span><span class="n">meshFileName</span><span class="w"> </span><span class="n">implicitLSFile</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">bwLS</span><span class="w"> </span><span class="n">bwCC</span><span class="w"> </span><span class="n">maxID</span><span class="w"> </span><span class="n">bwLS0</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">PC</span><span class="w"> </span><span class="n">param</span><span class="w"> </span><span class="n">P0</span><span class="w"> </span><span class="n">oriented</span><span class="w"> </span><span class="n">sst</span><span class="w"> </span><span class="n">ssf</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">numPoints</span><span class="w"> </span><span class="n">sharpnessAngle</span><span class="w"> </span><span class="n">edgeSensitivity</span><span class="w"> </span><span class="n">neighborRadius</span><span class="w"> </span><span class="n">OBJ</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">tar_length</span><span class="w"> </span><span class="n">num_iter</span><span class="w"> </span><span class="n">protect_constraintsintCount</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="n">numBdy</span><span class="w"> </span><span class="n">eulerChi</span><span class="w"> </span><span class="n">intersects</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">PU</span><span class="w"> </span><span class="n">PNU</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">V</span><span class="w"></span>

<span class="c">%% View Point Cloud Intersection with Data ================================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="c">% Choose time point to be visualized</span><span class="w"></span>
<span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">;</span><span class="w"></span>

<span class="c">% Load raw image data</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">isempty</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">))</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">loadTime</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">rescaleStackToUnitAspect</span><span class="p">();</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Load point cloud from file</span><span class="w"></span>
<span class="n">pointCloudFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s">'objFiles/pointCloud_T%03d.obj'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="n">v3D</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOBJ</span><span class="p">(</span><span class="n">pointCloudFileName</span><span class="p">);</span><span class="w"></span>

<span class="c">% Choose the slice to be visualized ---------------------------------------</span><span class="w"></span>
<span class="n">sliceNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="n">sliceDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'z'</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'x'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="k">elseif</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'y'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="k">elseif</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'z'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="s">'Invalid slice dimension'</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Find point cloud intersection with the image plane ----------------------</span><span class="w"></span>
<span class="n">incThresh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">inPlane</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">v3D</span><span class="p">(:,</span><span class="w"> </span><span class="n">sliceDimNum</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sliceNum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">incThresh</span><span class="p">;</span><span class="w"></span>

<span class="c">% Generate figure ---------------------------------------------------------</span><span class="w"></span>
<span class="nb">imshow</span><span class="p">(</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">getSlice</span><span class="p">(</span><span class="w"> </span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="n">sliceNum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="n">hold</span><span class="w"> </span><span class="s">on</span><span class="w"></span>

<span class="c">% scatter3(v3D(inPlane, 1), v3D(inPlane, 2), v3D(inPlane, 3), 'filled', 'r');</span><span class="w"></span>
<span class="nb">scatter</span><span class="p">(</span><span class="n">v3D</span><span class="p">(</span><span class="n">inPlane</span><span class="p">,</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"> </span><span class="n">v3D</span><span class="p">(</span><span class="n">inPlane</span><span class="p">,</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'r'</span><span class="p">);</span><span class="w"></span>

<span class="n">hold</span><span class="w"> </span><span class="s">off</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">tidx</span><span class="w"> </span><span class="n">pointCloudFileName</span><span class="w"> </span><span class="n">v3D</span><span class="w"> </span><span class="n">sliceNum</span><span class="w"> </span><span class="n">sliceDim</span><span class="w"> </span><span class="n">sliceDimNum</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">incThresh</span><span class="w"> </span><span class="n">inPlane</span><span class="w"> </span><span class="n">plotDim</span><span class="w"></span>

<span class="c">%% View Mesh Intersection With Data (Uses 'gptoolbox') ====================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="c">% Choose time point to be visualized</span><span class="w"></span>
<span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">;</span><span class="w"></span>

<span class="c">% Load raw image data</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">isempty</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">))</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">loadTime</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">rescaleStackToUnitAspect</span><span class="p">();</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Load mesh from file</span><span class="w"></span>
<span class="n">meshFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="s">'meshFiles/mesh_T%03d.off'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOFF</span><span class="p">(</span><span class="n">meshFile</span><span class="p">);</span><span class="w"></span>
<span class="c">% V = V(:, [3 2 1]); % Re-order axes for visualization purposes</span><span class="w"></span>

<span class="c">% mesh = read_ply_mod('MorphSnakesOutput/mesh_DP_000001.ply');</span><span class="w"></span>
<span class="c">% trisurf(triangulation(mesh.f, mesh.v)); axis equal</span><span class="w"></span>
<span class="c">% [F, V, ~, ~] = isotropic_remeshing(mesh.f, mesh.v, 10, 5);</span><span class="w"></span>
<span class="c">% oldV = V;</span><span class="w"></span>
<span class="c">% V = oldV(:, [2 1 3]);</span><span class="w"></span>

<span class="c">% Choose the slice to be visualized ---------------------------------------</span><span class="w"></span>
<span class="n">sliceNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span><span class="w"> </span><span class="c">% round(1345/2);</span><span class="w"></span>
<span class="n">sliceDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'x'</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'x'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="k">elseif</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'y'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="k">elseif</span><span class="w"> </span><span class="nb">strcmpi</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="s">'z'</span><span class="p">)</span><span class="w"></span>
<span class="n">sliceDimNum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="n">plotDim</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="nb">error</span><span class="p">(</span><span class="s">'Invalid slice dimension'</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Calculate the contour intersection of the mesh with the plane -----------</span><span class="w"></span>
<span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">UF</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">slice_isolines</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="n">sliceDimNum</span><span class="p">),</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">sliceNum</span><span class="p">,</span><span class="w"> </span><span class="s">'Manifold'</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="n">UE</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">edges</span><span class="p">(</span><span class="nb">triangulation</span><span class="p">(</span><span class="n">UF</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">));</span><span class="w"></span>

<span class="n">inSlice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">find</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">(:,</span><span class="w"> </span><span class="n">sliceDimNum</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sliceNum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-10</span><span class="p">);</span><span class="w"></span>
<span class="n">C</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">U</span><span class="p">(</span><span class="n">inSlice</span><span class="p">,</span><span class="w"> </span><span class="p">:);</span><span class="w"></span>
<span class="n">CE</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">UE</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">ismember</span><span class="p">(</span><span class="n">UE</span><span class="p">,</span><span class="w"> </span><span class="n">inSlice</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">:);</span><span class="w"></span>
<span class="n">CE</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">changem</span><span class="p">(</span><span class="n">CE</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">inSlice</span><span class="p">);</span><span class="w"></span>

<span class="c">% Generate figure ---------------------------------------------------------</span><span class="w"></span>
<span class="nb">imshow</span><span class="p">(</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">getSlice</span><span class="p">(</span><span class="w"> </span><span class="n">sliceDim</span><span class="p">,</span><span class="w"> </span><span class="n">sliceNum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">hold</span><span class="w"> </span><span class="s">on</span><span class="w"></span>

<span class="c">% scatter3(C(:,1), C(:,2), C(:,3), 'filled', 'r');</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">CE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="nb">plot</span><span class="p">([</span><span class="n">C</span><span class="p">(</span><span class="n">CE</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">CE</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">1</span><span class="p">))],</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="p">[</span><span class="n">C</span><span class="p">(</span><span class="n">CE</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">CE</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">plotDim</span><span class="p">(</span><span class="mi">2</span><span class="p">))],</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'-or'</span><span class="p">,</span><span class="w"> </span><span class="s">'LineWidth'</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">'MarkerFaceColor'</span><span class="p">,</span><span class="w"> </span><span class="s">'r'</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">hold</span><span class="w"> </span><span class="n">off</span><span class="w"></span>

<span class="c">% trisurf(triangulation(UF, U), 'FaceColor', 0.8*[1 1 1]);</span><span class="w"></span>
<span class="c">% hold on</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% scatter3(C(:,1), C(:,2), C(:,3), 'filled', 'r');</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% for i = 1:size(CE,1)</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%     plot3([C(CE(i,1),1); C(CE(i,2),1)], ...</span><span class="w"></span>
<span class="c">%         [C(CE(i,1),2); C(CE(i,2),2)], ...</span><span class="w"></span>
<span class="c">%         [C(CE(i,1),3); C(CE(i,2),3)], '-ob', 'LineWidth', 2);</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% end</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% hold off</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% xlabel('x'); ylabel('y'); zlabel('z');</span><span class="w"></span>
<span class="c">% axis equal</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">tidx</span><span class="w">  </span><span class="n">meshFIleC</span><span class="w"> </span><span class="n">CE</span><span class="w"> </span><span class="n">UE</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">plotDim</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">AC</span><span class="w"> </span><span class="n">GC</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">UF</span><span class="w"> </span><span class="n">inSlice</span><span class="w"> </span><span class="n">sliceNum</span><span class="w"> </span><span class="n">sliceDim</span><span class="w"> </span><span class="n">sliceDimNum</span><span class="w"></span>

<span class="c">%% View the Data on the Mesh Surface ======================================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="n">clc</span><span class="w"></span>

<span class="s">%</span><span class="w"> </span><span class="s">Choose</span><span class="w"> </span><span class="s">time</span><span class="w"> </span><span class="s">point</span><span class="w"> </span><span class="s">to</span><span class="w"> </span><span class="s">be</span><span class="w"> </span><span class="s">visualized</span><span class="w"></span>
<span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">;</span><span class="w"></span>

<span class="c">% Load raw image data</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">currentTime</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">isempty</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">))</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">loadTime</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="n">xp</span><span class="p">.</span><span class="n">rescaleStackToUnitAspect</span><span class="p">();</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Load mesh from file</span><span class="w"></span>
<span class="n">meshFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="s">'meshFiles/mesh_T%03d.off'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOFF</span><span class="p">(</span><span class="n">meshFile</span><span class="p">);</span><span class="w"></span>

<span class="c">% The raw data image stack</span><span class="w"></span>
<span class="n">IV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="n">image</span><span class="p">.</span><span class="n">apply</span><span class="p">();</span><span class="w"></span>
<span class="n">IV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">double</span><span class="p">(</span><span class="n">IV</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span><span class="o">/</span><span class="mi">65535</span><span class="p">;</span><span class="w"></span>
<span class="c">% IV{1} = imadjustn(IV{1});</span><span class="w"></span>
<span class="c">% IV{2} = imadjustn(IV{2});</span><span class="w"></span>
<span class="c">% IV{3} = zeros(size(IV{1})); % RGB requires 3 channels</span><span class="w"></span>

<span class="c">% Texture patch options</span><span class="w"></span>
<span class="n">textureOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">EdgeColor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'none'</span><span class="p">;</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">numLayers</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">layerSpacing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="n">texture_patch_3d</span><span class="p">(</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">]),</span><span class="w"> </span><span class="n">IV</span><span class="p">,</span><span class="w"> </span><span class="n">textureOptions</span><span class="p">);</span><span class="w"></span>
<span class="n">axis</span><span class="w"> </span><span class="s">equal</span><span class="w"></span>
<span class="nb">colormap</span><span class="w"> </span><span class="nb">bone</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">IV</span><span class="w"> </span><span class="n">textureOptions</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">meshFile</span><span class="w"></span>

<span class="c">%% Inspect All Meshes in 3D ===============================================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">()</span><span class="w"></span>

<span class="c">% Load the mesh</span><span class="w"></span>
<span class="n">meshFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="s">'meshFiles/mesh_T%03d.off'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOFF</span><span class="p">(</span><span class="n">meshFile</span><span class="p">);</span><span class="w"></span>

<span class="c">% Plot the mesh in 3d. Color here by Z coordinate</span><span class="w"></span>
<span class="nb">trisurf</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="n">V</span><span class="p">(:,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'EdgeColor'</span><span class="p">,</span><span class="w"> </span><span class="s">'none'</span><span class="p">,</span><span class="w"> </span><span class="s">'FaceAlpha'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"></span>

<span class="nb">hold</span><span class="w"> </span><span class="n">on</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">V</span><span class="o">&lt;=</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">V</span><span class="o">&lt;=</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">V</span><span class="o">&lt;=</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'r'</span><span class="p">);</span><span class="w"></span>
<span class="n">hold</span><span class="w"> </span><span class="s">off</span><span class="w"></span>

<span class="nb">title</span><span class="p">([</span><span class="s">'t='</span><span class="w"> </span><span class="nb">num2str</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span><span class="w"></span>
<span class="nb">axis</span><span class="w"> </span><span class="n">equal</span><span class="w"></span>
<span class="nb">view</span><span class="p">([</span><span class="o">-</span><span class="mi">80</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="c">% view(1)</span><span class="w"></span>
<span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">meshFile</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">F</span><span class="w"></span>

<span class="c">%% ************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">%               PART 2: TubULAR -- SURFACE PARAMETERIZATION</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>

<span class="c">%% Set Up TubULAR Directories =============================================</span><span class="w"></span>
<span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="s">'TubULAR_Results'</span><span class="p">,</span><span class="w"> </span><span class="s">'dir'</span><span class="p">)</span><span class="w"></span>

<span class="nb">mkdir</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'TubULAR_Results'</span><span class="p">));</span><span class="w"></span>

<span class="c">% Re-write meshes into the format used by TubULAR</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">()</span><span class="w"></span>

<span class="n">outputMeshFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">([</span><span class="s">'TubULAR_Results/'</span><span class="k">...</span><span class="w"></span>
<span class="n">detectOptions</span><span class="p">.</span><span class="n">ofn_smoothply</span><span class="w"> </span><span class="s">'%06d.ply'</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">outputMeshFile</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">overwrite</span><span class="w"></span>

<span class="c">% Load the mesh</span><span class="w"></span>
<span class="n">meshFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s">'meshFiles/mesh_T%03d.off'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOFF</span><span class="p">(</span><span class="n">meshFile</span><span class="p">);</span><span class="w"></span>

<span class="n">VN</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="s">'Weighting'</span><span class="p">,</span><span class="w"> </span><span class="s">'angle'</span><span class="p">);</span><span class="w"></span>
<span class="n">VN</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">normalizerow</span><span class="p">(</span><span class="n">VN</span><span class="p">);</span><span class="w"></span>

<span class="n">plywrite_with_normals</span><span class="p">(</span><span class="n">outputMeshFile</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">VN</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">meshFile</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">VN</span><span class="w"> </span><span class="n">outputMeshFile</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>


<span class="c">%% Initialize the TubULAR Object ==========================================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="n">tubOpts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">meshDir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="s">'TubULAR_Results'</span><span class="p">);</span><span class="w">      </span><span class="c">% Director where meshes produced in previous part reside. All TubULAR results will be stored relative to this directory</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">flipy</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">flipy</span><span class="p">;</span><span class="w">               </span><span class="c">% Set to true if data volume axes are inverted in chirality wrt physical lab coordinates</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">timeInterval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">timeInterval</span><span class="p">;</span><span class="w"> </span><span class="c">% Spacing between adjacent timepoints in units of timeUnits</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">timeUnits</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">timeUnits</span><span class="p">;</span><span class="w">       </span><span class="c">% Units of time, so that adjacent timepoints are timeUnits * timeInterval apart</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">spaceUnits</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">spaceUnits</span><span class="p">;</span><span class="w">     </span><span class="c">% Units of space in LaTeX, for ex '$mu$m' for micron</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">nU</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">nU</span><span class="p">;</span><span class="w">         </span><span class="c">% How many points along the longitudinal axis to sample surface</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">nV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">masterSettings</span><span class="p">.</span><span class="n">nV</span><span class="p">;</span><span class="w">         </span><span class="c">% How many points along the circumferential axis to sample surface</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">t0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c">% Reference timepoint used to define surface-Lagrangian and Lagrangian measurements</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">normalShift</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">        </span><span class="c">% Additional dilation acting on surface for texture mapping</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">a_fixed</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">          </span><span class="c">% Fixed aspect ratio of pullback images. Setting to 1.0 is most conformal mapping option.</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">adjustlow</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1.00</span><span class="p">;</span><span class="w">       </span><span class="c">% Floor for intensity adjustment</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">adjusthigh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">99.9</span><span class="p">;</span><span class="w">      </span><span class="c">% ceil for intensity adjustment (clip)</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">phiMethod</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'curved3d'</span><span class="p">;</span><span class="w"> </span><span class="c">% Method for following surface in surface-Lagrangian mapping [(s,phi) coordinates]</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">lambda_mesh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">        </span><span class="c">% Smoothing applied to the mesh before DEC measurements</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">lambda</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">             </span><span class="c">% Smoothing applied to computed values on the surface</span><span class="w"></span>
<span class="n">tubOpts</span><span class="p">.</span><span class="n">lambda_err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">         </span><span class="c">% Additional smoothing parameter, optional</span><span class="w"></span>

<span class="nb">disp</span><span class="p">(</span><span class="s">'defining TubULAR class instance (tubi= tubular instance)'</span><span class="p">)</span><span class="w"></span>
<span class="n">tubi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">TubULAR</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="w"> </span><span class="n">tubOpts</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'done defining TubULAR instance'</span><span class="p">)</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">tubOpts</span><span class="w"></span>

<span class="c">%% Inspect All Meshes in 3D (TubULAR Style) ===============================</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">tp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="w"></span>

<span class="c">% Load the mesh</span><span class="w"></span>
<span class="n">meshfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">fullFileBase</span><span class="p">.</span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="nb">mesh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">read_ply_mod</span><span class="p">(</span><span class="n">meshfn</span><span class="p">);</span><span class="w"></span>

<span class="c">% Plot the mesh in 3D</span><span class="w"></span>
<span class="nb">trisurf</span><span class="p">(</span><span class="nb">mesh</span><span class="p">.</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="nb">mesh</span><span class="p">.</span><span class="n">v</span><span class="p">(:,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">mesh</span><span class="p">.</span><span class="n">v</span><span class="p">(:,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">mesh</span><span class="p">.</span><span class="n">v</span><span class="p">(:,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">mesh</span><span class="p">.</span><span class="n">v</span><span class="p">(:,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'Edgecolor'</span><span class="p">,</span><span class="w"> </span><span class="s">'none'</span><span class="p">,</span><span class="w"> </span><span class="s">'Facealpha'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w"></span>
<span class="nb">title</span><span class="p">([</span><span class="s">'t='</span><span class="w"> </span><span class="nb">num2str</span><span class="p">(</span><span class="n">tp</span><span class="p">)]);</span><span class="w"></span>
<span class="n">axis</span><span class="w"> </span><span class="s">equal</span><span class="w"></span>
<span class="nb">view</span><span class="p">([</span><span class="o">-</span><span class="mi">80</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>

<span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">tp</span><span class="w"> </span><span class="n">meshfn</span><span class="w"> </span><span class="nb">mesh</span><span class="w"></span>

<span class="c">%% Obtain APDV Coordinates of the Surface =================================</span><span class="w"></span>
<span class="c">% There are ftwo options for obtaining these coordinates.</span><span class="w"></span>
<span class="c">%   1. Automatically determine A and P by the extremal points of the</span><span class="w"></span>
<span class="c">%   surface mesh along the elongated axis of the mesh, and define DV as</span><span class="w"></span>
<span class="c">%   pointing perpendicular to this.</span><span class="w"></span>
<span class="c">%   2. Train in iLastik for an anterior spot in 3d (A), a posterior spot in</span><span class="w"></span>
<span class="c">%   3d (P), and a spot which is dorsal to the line connecting A and P. Any</span><span class="w"></span>
<span class="c">%   dorsal point is fine, as long as it points dorsal to the AP axis</span><span class="w"></span>
<span class="c">%   defined by A and P. See picture below.</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">%     example:</span><span class="w"></span>
<span class="c">%                 D</span><span class="w"></span>
<span class="c">%                 |</span><span class="w"></span>
<span class="c">%                 |</span><span class="w"></span>
<span class="c">%       A -----------------P</span><span class="w"></span>
<span class="c">%</span><span class="w"></span>
<span class="c">% Here we use option 1.</span><span class="w"></span>
<span class="c">% Define global orientation frame (for viewing in canonical frame)</span><span class="w"></span>
<span class="c">% Compute APDV coordinate system</span><span class="w"></span>
<span class="n">alignAPDVOpts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">alignAPDVOpts</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">computeAPDVCoords</span><span class="p">(</span><span class="n">alignAPDVOpts</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%% Determine A-P Points/Endcaps From Point Cloud ==========================</span><span class="w"></span>
<span class="nb">close</span><span class="w"> </span><span class="nb">all</span><span class="p">;</span><span class="w"> </span><span class="nb">clc</span><span class="p">;</span><span class="w"></span>

<span class="nb">figure</span><span class="p">(</span><span class="s">'units'</span><span class="p">,</span><span class="w"> </span><span class="s">'normalized'</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'outerposition'</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mf">0.5</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w">  </span><span class="s">'color'</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>

<span class="c">% Store point LOCATIONS</span><span class="w"></span>
<span class="n">apts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">zeros</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="n">ppts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">zeros</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="c">% Store encap vertex IDs</span><span class="w"></span>
<span class="n">allAntEndCaps</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="n">allPosEndCaps</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="p">()</span><span class="w"></span>

<span class="n">tidx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">tIdx</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Processing time point T = %d\n'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="c">% Read in point cloud from file</span><span class="w"></span>
<span class="n">pointCloudFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">fullfile</span><span class="p">(</span><span class="w"> </span><span class="n">projectDir</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="nb">sprintf</span><span class="p">(</span><span class="s">'objFiles/pointCloud_T%03d.obj'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">readOBJ</span><span class="p">(</span><span class="n">pointCloudFileName</span><span class="p">);</span><span class="w"></span>

<span class="c">% Read in mesh from file</span><span class="w"></span>
<span class="n">meshFileName</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">fullFileBase</span><span class="p">.</span><span class="n">mesh</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="nb">mesh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">read_ply_mod</span><span class="p">(</span><span class="n">meshFileName</span><span class="p">);</span><span class="w"></span>
<span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">mesh</span><span class="p">.</span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">mesh</span><span class="p">.</span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="n">E</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">edges</span><span class="p">(</span><span class="nb">triangulation</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">V</span><span class="p">));</span><span class="w"></span>

<span class="c">% Determine vertex neighbor 1-rings</span><span class="w"></span>
<span class="n">allNIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">cell</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">nIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">unique</span><span class="p">(</span><span class="n">E</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">E</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">:));</span><span class="w"></span>
<span class="n">nIDx</span><span class="p">(</span><span class="n">nIDx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">i</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="n">allNIDx</span><span class="p">{</span><span class="nb">i</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">nIDx</span><span class="p">(:);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">% Format Point Cloud for Endcap Extraction ----------------------------</span><span class="w"></span>
<span class="c">% Point cloud is matched to mesh vertices. The point cloud then</span><span class="w"></span>
<span class="c">% undergoes several rounds of topological erosion/dilation to smooth</span><span class="w"></span>
<span class="c">% out the boundaries of contiguous regions not included in the point</span><span class="w"></span>
<span class="c">% set</span><span class="w"></span>

<span class="c">% Point match the point cloud to mesh vertices</span><span class="w"></span>
<span class="n">PVIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">unique</span><span class="p">(</span><span class="n">knnsearch</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">));</span><span class="w"></span>

<span class="n">inPC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">ismember</span><span class="p">((</span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">PVIDx</span><span class="p">);</span><span class="w"></span>

<span class="c">% Dilate the point set - points that are adjacent to points contained</span><span class="w"></span>
<span class="c">% within the set, but are not currently contained within the set are</span><span class="w"></span>
<span class="c">% added to the set</span><span class="w"></span>
<span class="n">dilateIter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">dilateIter</span><span class="w"></span>

<span class="c">% Find all points adjacent to points in the point set</span><span class="w"></span>
<span class="n">adjIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">vertcat</span><span class="p">(</span><span class="n">allNIDx</span><span class="p">{</span><span class="n">inPC</span><span class="p">});</span><span class="w"></span>

<span class="n">newIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">~</span><span class="n">inPC</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nb">ismember</span><span class="p">((</span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">adjIDx</span><span class="p">);</span><span class="w"></span>
<span class="n">inPC</span><span class="p">(</span><span class="n">newIDx</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="c">% Erode the point set - boundary points, that are included in the point</span><span class="w"></span>
<span class="c">% set, but adjacent to points that are not included in the point set,</span><span class="w"></span>
<span class="c">% are removed from the point set</span><span class="w"></span>
<span class="n">erodeIter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">erodeIter</span><span class="w"></span>

<span class="c">% Find all points adjacent to points that are NOT in the point set</span><span class="w"></span>
<span class="n">adjIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">vertcat</span><span class="p">(</span><span class="n">allNIDx</span><span class="p">{</span><span class="o">~</span><span class="n">inPC</span><span class="p">});</span><span class="w"></span>

<span class="n">bdyIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">inPC</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nb">ismember</span><span class="p">((</span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">adjIDx</span><span class="p">);</span><span class="w"></span>
<span class="n">inPC</span><span class="p">(</span><span class="n">bdyIDx</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="n">PVIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">find</span><span class="p">(</span><span class="n">inPC</span><span class="p">);</span><span class="w"></span>

<span class="c">% Determine A-P Points and Endcaps ------------------------------------</span><span class="w"></span>
<span class="c">% This method works by removing all points with distances below a user</span><span class="w"></span>
<span class="c">% specified threshold and then denoting the two largest remaining mesh</span><span class="w"></span>
<span class="c">% components as the respective endcaps. This method will FAIL for</span><span class="w"></span>
<span class="c">% pathological cases with strange connectivity (e.g. the two</span><span class="w"></span>
<span class="c">% prospective endcap regions are connected by a thin band of vertices).</span><span class="w"></span>
<span class="c">% Empirical testing for this data set show that the anterior cap ALWAYS</span><span class="w"></span>
<span class="c">% has more vertices than the posterior cap - if this were not true the</span><span class="w"></span>
<span class="c">% user could use spatial orientation information to delineate which cap</span><span class="w"></span>

<span class="c">% Determine the distance of each mesh vertex from the nearest vertex</span><span class="w"></span>
<span class="c">% matched to a point cloud point</span><span class="w"></span>
<span class="n">D</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">heat_geodesic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">PVIDx</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="s">'Legacy'</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="n">Dthresh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_vertex_from_mesh</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Dthresh</span><span class="p">);</span><span class="w"></span>
<span class="n">FP</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">FP</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="p">[</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_unreferenced_vertices_from_mesh</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">);</span><span class="w"></span>

<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">VA</span><span class="p">,</span><span class="w"> </span><span class="n">AIDx</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_isolated_mesh_components</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_vertex_from_mesh</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="n">AIDx</span><span class="p">);</span><span class="w"></span>
<span class="n">FP</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">FP</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="p">:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span><span class="w"></span>
<span class="p">[</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_unreferenced_vertices_from_mesh</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">remove_isolated_mesh_components</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">);</span><span class="w"></span>

<span class="n">AIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">knnsearch</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">VA</span><span class="p">);</span><span class="w"></span>
<span class="n">PIDx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">knnsearch</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">VP</span><span class="p">);</span><span class="w"></span>

<span class="c">% The A-P points are simply taken to be the locations of maximum</span><span class="w"></span>
<span class="c">% distance within each patch</span><span class="w"></span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">AID</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">AIDx</span><span class="p">));</span><span class="w"> </span><span class="n">AID</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">AIDx</span><span class="p">(</span><span class="n">AID</span><span class="p">);</span><span class="w"></span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="w"> </span><span class="n">PID</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">PIDx</span><span class="p">));</span><span class="w"> </span><span class="n">PID</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">PIDx</span><span class="p">(</span><span class="n">PID</span><span class="p">);</span><span class="w"></span>

<span class="n">apts</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span><span class="w"> </span><span class="p">:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">AID</span><span class="p">,</span><span class="w"> </span><span class="p">:);</span><span class="w"></span>
<span class="n">ppts</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span><span class="w"> </span><span class="p">:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="w"> </span><span class="p">:);</span><span class="w"></span>

<span class="n">allAntEndCaps</span><span class="p">{</span><span class="n">tidx</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">AIDx</span><span class="p">(:);</span><span class="w"></span>
<span class="n">allPosEndCaps</span><span class="p">{</span><span class="n">tidx</span><span class="p">}</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">PIDx</span><span class="p">(:);</span><span class="w"></span>

<span class="c">% View Results --------------------------------------------------------</span><span class="w"></span>

<span class="nb">trisurf</span><span class="p">(</span><span class="nb">triangulation</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">),</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'FaceColor'</span><span class="p">,</span><span class="w"> </span><span class="s">'interp'</span><span class="p">,</span><span class="w"> </span><span class="s">'EdgeColor'</span><span class="p">,</span><span class="w"> </span><span class="s">'k'</span><span class="p">);</span><span class="w"></span>
<span class="n">hold</span><span class="w"> </span><span class="s">on</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">PVIDx</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PVIDx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PVIDx</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'k'</span><span class="p">);</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">AIDx</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">AIDx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">AIDx</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'g'</span><span class="p">)</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">PIDx</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PIDx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PIDx</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'c'</span><span class="p">)</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">AID</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">AID</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">AID</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'r'</span><span class="p">)</span><span class="w"></span>
<span class="nb">scatter3</span><span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="s">'filled'</span><span class="p">,</span><span class="w"> </span><span class="s">'m'</span><span class="p">)</span><span class="w"></span>
<span class="nb">hold</span><span class="w"> </span><span class="n">off</span><span class="w"></span>
<span class="nb">axis</span><span class="w"> </span><span class="n">equal</span><span class="w"></span>
<span class="nb">colorbar</span><span class="w"></span>
<span class="nb">view</span><span class="p">([</span><span class="o">-</span><span class="mi">85</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">45</span><span class="p">]);</span><span class="w"></span>
<span class="nb">title</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s">'T = %d\n'</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">));</span><span class="w"></span>

<span class="nb">pause</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="nb">clear</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">tidx</span><span class="w"> </span><span class="n">pointCloudFileName</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">PN</span><span class="w"> </span><span class="n">meshFileName</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">E</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">allNIDx</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="n">nIDx</span><span class="w"> </span><span class="n">PVIDx</span><span class="w"> </span><span class="n">inPC</span><span class="w"> </span><span class="n">dilateIter</span><span class="w"> </span><span class="n">adjIDx</span><span class="w"> </span><span class="n">newIDx</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">erodeIter</span><span class="w"> </span><span class="n">bdyIDx</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="n">Dthresh</span><span class="w"> </span><span class="n">FP</span><span class="w"> </span><span class="n">VP</span><span class="w"> </span><span class="n">FA</span><span class="w"> </span><span class="n">VA</span><span class="w"> </span><span class="n">AIDx</span><span class="w"> </span><span class="n">PIDx</span><span class="w"> </span><span class="n">AID</span><span class="w"> </span><span class="n">PID</span><span class="w"> </span><span class="n">ts</span><span class="w"></span>

<span class="c">%% Save A-P Points for Centerline Computation =============================</span><span class="w"></span>

<span class="n">apdvOpts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span><span class="w"></span>
<span class="n">apdvOpts</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="n">apdvOpts</span><span class="p">.</span><span class="n">custom_apts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">apts</span><span class="p">;</span><span class="w"></span>
<span class="n">apdvOpts</span><span class="p">.</span><span class="n">custom_ppts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ppts</span><span class="p">;</span><span class="w"></span>
<span class="n">apdvOpts</span><span class="p">.</span><span class="n">smwindow</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="p">[</span><span class="n">apts_sm</span><span class="p">,</span><span class="w"> </span><span class="n">ppts_sm</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">computeAPDpoints</span><span class="p">(</span><span class="n">apdvOpts</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Align Meshes in the APDV Global Frame and Plot Them ====================</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Aligning/plotting meshes... '</span><span class="p">);</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">alignMeshesAPDV</span><span class="p">(</span><span class="n">alignAPDVOpts</span><span class="p">);</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Done\n'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Plot All Textured Meshes in 3D (OPTIONAL: this is SLOW) ================</span><span class="w"></span>
<span class="c">% Establish texture patch options</span><span class="w"></span>
<span class="n">metadat</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">metadat</span><span class="p">.</span><span class="n">reorient_faces</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w">            </span><span class="c">% set to true if some mesh normals may be inverted (requires gptoolbox if true)</span><span class="w"></span>
<span class="n">metadat</span><span class="p">.</span><span class="n">normal_shift</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">normalShift</span><span class="w"> </span><span class="p">;</span><span class="w">   </span><span class="c">% normal push, in pixels, along normals defined in data XYZ space</span><span class="w"></span>
<span class="n">metadat</span><span class="p">.</span><span class="n">texture_axis_order</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w">      </span><span class="c">% texture space sampling. If the surface and dataspace have axis permutation, enter that here</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">PSize</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">;</span><span class="w">          </span><span class="c">% Psize is the linear dimension of the grid drawn on each triangular face. Set PSize &gt; 1 for refinement of texture on each triangle of the surface triangulation. Higher numbers are slower but give more detailed images.</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">numLayers</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w">  </span><span class="c">% how many layers to MIP over/bundle into stack, as [outward, inward]</span><span class="w"></span>
<span class="n">textureOptions</span><span class="p">.</span><span class="n">layerSpacing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">;</span><span class="w">   </span><span class="c">% Distance between layers over which we take MIP, in pixels,</span><span class="w"></span>

<span class="c">% Plot on surface for all timepoints</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotSeriesOnSurfaceTexturePatch</span><span class="p">(</span><span class="n">metadat</span><span class="p">,</span><span class="w"> </span><span class="n">textureOptions</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Extract Centerlines ====================================================</span><span class="w"></span>
<span class="c">% Note: these just need to be 'reasonable' centerlines for topological</span><span class="w"></span>
<span class="c">% checks on the orbifold cuts. Therefore, use as large a resolution ('res')</span><span class="w"></span>
<span class="c">% as possible that still forms a centerline passing through the mesh</span><span class="w"></span>
<span class="c">% surface, since the centerline computed here is just for constraining the</span><span class="w"></span>
<span class="c">% mapping to the plane.</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w">         </span><span class="c">% overwrite previous results</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">overwrite_ims</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w">     </span><span class="c">% overwrite previous results</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">weight</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w">               </span><span class="c">% for speedup of centerline extraction. Larger is less precise</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">exponent</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">;</span><span class="w">            </span><span class="c">% how heavily to scale distance transform for speed through voxel</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="p">;</span><span class="w">                 </span><span class="c">% resolution of distance tranform grid in which to compute centerlines</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">preview</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w">           </span><span class="c">% preview intermediate results</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">reorient_faces</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w">    </span><span class="c">% not needed for our well-constructed meshes</span><span class="w"></span>
<span class="n">cntrlineOpts</span><span class="p">.</span><span class="n">dilation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w">              </span><span class="c">% how many voxels to dilate the segmentation inside/outside before path computation</span><span class="w"></span>
<span class="c">% Note: this can take about 400s per timepoint for res=2.0, so use as big a</span><span class="w"></span>
<span class="c">%   res value as possible.</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Extracting centerlines... '</span><span class="p">);</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">generateFastMarchingCenterlines</span><span class="p">(</span><span class="n">cntrlineOpts</span><span class="p">)</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Done\n'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Identify Anomalies in Centerline Data ==================================</span><span class="w"></span>

<span class="n">idOptions</span><span class="p">.</span><span class="n">ssr_thes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"> </span><span class="c">% Distance of sum squared residuals in 'spaceUnits'</span><span class="w"></span>
<span class="c">% as a threshold for removing spurious centerlines</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Cleaning centerlines... '</span><span class="p">);</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">cleanFastMarchingCenterlines</span><span class="p">(</span><span class="n">idOptions</span><span class="p">);</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Done\n'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Generate Cylindrical Mesh ==============================================</span><span class="w"></span>
<span class="c">% Transforms a topological sphere into a topological cylinder</span><span class="w"></span>

<span class="c">% Look for options on disk. If not saved, define options</span><span class="w"></span>
<span class="n">overwrite_endcap_options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">fileName</span><span class="p">.</span><span class="n">endcapOptions</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">overwrite_endcap_options</span><span class="w"></span>

<span class="n">endcapOpts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">(</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'custom_aidx'</span><span class="p">,</span><span class="w"> </span><span class="n">allAntEndCaps</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="c">  % Points that will be removed to create the anterior endcap</span><span class="w"></span>
<span class="s">'custom_pidx'</span><span class="p">,</span><span class="w"> </span><span class="n">allPosEndCaps</span><span class="p">,</span><span class="w"> </span><span class="k">...</span><span class="c">  % Points that will be removed to create the posterior endcap</span><span class="w"></span>
<span class="s">'tref'</span><span class="p">,</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">t0</span><span class="p">);</span><span class="w">   </span><span class="c">% Reference timepoint at which time dorsal-most endcap vertices are defined</span><span class="w"></span>

<span class="n">tubi</span><span class="p">.</span><span class="n">setEndcapOptions</span><span class="p">(</span><span class="n">endcapOpts</span><span class="p">);</span><span class="w"></span>

<span class="c">% Save the options to disk</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">saveEndcapOptions</span><span class="p">();</span><span class="w"></span>

<span class="k">else</span><span class="w"></span>

<span class="c">% load endcapOpts</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">loadEndcapOptions</span><span class="p">();</span><span class="w"></span>
<span class="n">endcapOpts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">endcapOptions</span><span class="p">;</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>

<span class="n">methodOpts</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">methodOpts</span><span class="p">.</span><span class="n">save_figs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">    </span><span class="c">% save images of cutMeshes along the way</span><span class="w"></span>
<span class="n">methodOpts</span><span class="p">.</span><span class="n">preview</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">     </span><span class="c">% display intermediate results</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">sliceMeshEndcaps</span><span class="p">(</span><span class="n">endcapOpts</span><span class="p">,</span><span class="w"> </span><span class="n">methodOpts</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="n">clear</span><span class="w"> </span><span class="s">overwrite_endcap_options</span><span class="w"></span>

<span class="c">%% Clean Cylinder Meshes ==================================================</span><span class="w"></span>
<span class="c">% This removes "ears" from the endcaps of the tubular meshes (cylindrical</span><span class="w"></span>
<span class="c">% meshes)</span><span class="w"></span>

<span class="n">cleanCylOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">cleanCylOptions</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Cleaning cylinder meshes... '</span><span class="p">);</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">cleanCylMeshes</span><span class="p">(</span><span class="n">cleanCylOptions</span><span class="p">)</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Done\n'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Generate Orbifold Cut Meshes ===========================================</span><span class="w"></span>
<span class="c">% Begin populating tubi.dir.mesh/gridCoords_nUXXXX_nVXXXX/</span><span class="w"></span>

<span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="c">% Iterate Through Time Points to Create Pullbacks</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="w"></span>
<span class="nb">disp</span><span class="p">([</span><span class="s">'NOW PROCESSING TIME POINT '</span><span class="p">,</span><span class="w"> </span><span class="nb">num2str</span><span class="p">(</span><span class="n">tt</span><span class="p">)]);</span><span class="w"></span>
<span class="n">tidx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xp</span><span class="p">.</span><span class="n">tIdx</span><span class="p">(</span><span class="n">tt</span><span class="p">);</span><span class="w"></span>

<span class="c">% Load the data for the current time point</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">setTime</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%----------------------------------------------------------------------</span><span class="w"></span>
<span class="c">% Create the Cut Mesh</span><span class="w"></span>
<span class="c">%----------------------------------------------------------------------</span><span class="w"></span>
<span class="n">cutMeshfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">fullFileBase</span><span class="p">.</span><span class="n">cutMesh</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">cutPathfn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sprintf</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">fullFileBase</span><span class="p">.</span><span class="n">cutPath</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">cutMeshfn</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="n">cutPathfn</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">overwrite</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nb">exist</span><span class="p">(</span><span class="n">cutMeshfn</span><span class="p">,</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'Overwriting cutMesh...'</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'cutMesh not found on disk. Generating cutMesh... '</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">generateCurrentCutMesh</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'Saving cutP image'</span><span class="p">)</span><span class="w"></span>
<span class="c">% Plot the cutPath (cutP) in 3D</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotCutPath</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">currentMesh</span><span class="p">.</span><span class="n">cutMesh</span><span class="p">,</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">currentMesh</span><span class="p">.</span><span class="n">cutPath</span><span class="p">)</span><span class="w"></span>
<span class="n">compute_pullback</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s">'Loading Cut Mesh from disk... '</span><span class="p">);</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">loadCurrentCutMesh</span><span class="p">()</span><span class="w"></span>
<span class="n">compute_pullback</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">currentMesh</span><span class="p">.</span><span class="n">cutPath</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="n">spcutMeshOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">spcutMeshOptions</span><span class="p">.</span><span class="n">t0_for_phi0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">t0set</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="c">% which timepoint do we define corners of pullback map</span><span class="w"></span>
<span class="n">spcutMeshOptions</span><span class="p">.</span><span class="n">save_phi0patch</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">spcutMeshOptions</span><span class="p">.</span><span class="n">iterative_phi0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">spcutMeshOptions</span><span class="p">.</span><span class="n">smoothingMethod</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'none'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotting</span><span class="p">.</span><span class="n">preview</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">generateCurrentSPCutMesh</span><span class="p">([],</span><span class="w"> </span><span class="n">spcutMeshOptions</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">% Compute the pullback if the cutMesh is ok</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">compute_pullback</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">~</span><span class="nb">exist</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="n">tubi</span><span class="p">.</span><span class="n">fullFileBase</span><span class="p">.</span><span class="n">im_sp</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="p">),</span><span class="w"> </span><span class="s">'file'</span><span class="p">)</span><span class="w"></span>
<span class="n">pbOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">generateCurrentPullbacks</span><span class="p">([],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="n">pbOptions</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'Skipping computation of pullback'</span><span class="p">)</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">end</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'Done with generating spcutMeshes and cutMeshes'</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Inspect Coordinate System Charts Using (s,phi) Coordinate system ('sp')</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">coordSys</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'sp'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">coordSystemDemo</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>


<span class="c">%% Smooth the (s, phi) Grid Meshes in Time ================================</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="c">% width of kernel, in #timepoints, to use in smoothing meshes</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">smoothDynamicSPhiMeshes</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">clear</span><span class="w"> </span><span class="s">options</span><span class="w"></span>

<span class="c">%% Plot the Time-Smoothed Meshes ==========================================</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">;</span><span class="w">  </span><span class="c">% width of kernel, in #timepoints, to use in smoothing meshes</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotSPCutMeshSmRS</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%% Inspect coordinate system charts using smoothed meshes</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">coordSys</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'spsm'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">coordSystemDemo</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="nb">clear</span><span class="w"> </span><span class="n">options</span><span class="w"></span>

<span class="c">%% Redo Pullbacks with Time-Smoothed Meshes ===============================</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'Create pullback using S,Phi coords with time-averaged Meshes'</span><span class="p">)</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">xp</span><span class="p">.</span><span class="n">fileMeta</span><span class="p">.</span><span class="n">timePoints</span><span class="w"></span>
<span class="nb">disp</span><span class="p">([</span><span class="s">'NOW PROCESSING TIME POINT '</span><span class="p">,</span><span class="w"> </span><span class="nb">num2str</span><span class="p">(</span><span class="n">tt</span><span class="p">)]);</span><span class="w"></span>
<span class="n">tidx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">tubi</span><span class="p">.</span><span class="n">xp</span><span class="p">.</span><span class="n">tIdx</span><span class="p">(</span><span class="n">tt</span><span class="p">);</span><span class="w"></span>

<span class="c">% Load the data for the current time point ------------------------</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">setTime</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">% Establish custom Options for MIP --&gt; choose which pullbacks to use</span><span class="w"></span>
<span class="n">pbOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">pbOptions</span><span class="p">.</span><span class="n">numLayers</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c">% how many onion layers over which to take MIP</span><span class="w"></span>
<span class="n">pbOptions</span><span class="p">.</span><span class="n">generate_spsm</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">pbOptions</span><span class="p">.</span><span class="n">generate_sp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">pbOptions</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">generateCurrentPullbacks</span><span class="p">([],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="n">pbOptions</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c">%% ************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">%          PART 4: TubULAR -- COMPUTATION OF TISSUE DEFORMATION</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>
<span class="c">% *************************************************************************</span><span class="w"></span>

<span class="c">%% Tile/Extend Smoothed Images in Y and Re-save ===========================</span><span class="w"></span>
<span class="c">% Skip if already done</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">coordsys</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'spsm'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">doubleCoverPullbackImages</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="nb">disp</span><span class="p">(</span><span class="s">'done'</span><span class="p">);</span><span class="w"></span>

<span class="c">%% Perform PIV on Pullback MIPS ===========================================</span><span class="w"></span>
<span class="c">% % Compute PIV either with built-in phase correlation or in PIVLab</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePIV2d</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%% Measure Velocities =====================================================</span><span class="w"></span>
<span class="nb">disp</span><span class="p">([</span><span class="s">'Making map from pixel to xyz to compute velocities '</span><span class="w"> </span><span class="k">...</span><span class="w"></span>
<span class="s">'in 3d for smoothed meshes...'</span><span class="p">]);</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">show_v3d_on_data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePIV3d</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">%% Lagrangian dynamics</span><span class="w"></span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">%% Pullback pathline time averaging of velocities</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">timeAverageVelocities</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="c">% Velocity plots for pathline time averaging</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">plot_vxyz</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">invertImage</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">averagingStyle</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'Lagrangian'</span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotTimeAvgVelocities</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="c">% Divergence and Curl (Helmholtz-Hodge) for Lagrangian</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">averagingStyle</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'Lagrangian'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">lambda</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">lambda_mesh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">helmholtzHodge</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">% Compressibility &amp; kinematics for Lagrangian</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measureMetricKinematics</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Metric Kinematics Kymographs &amp; Correlations -- Bandwidth Filtered</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotMetricKinematics</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">%% DYNAMICS of MATERIAL PATHLINES                                        %%</span><span class="w"></span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">%% Pullback pathlines connecting Lagrangian grids</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePullbackPathlines</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Query velocities along pathlines</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePathlineVelocities</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="c">% plot the pathline velocities</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">gridTopology</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'triangulated'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotPathlineVelocities</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">% Measure Pathline Kinematics</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePathlineMetricKinematics</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">% Plot Pathline Kinematics</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotPathlineMetricKinematics</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="w"></span>
<span class="c">%% Create ricci mesh at t0 to measure Beltrami coefficient in pathlines</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climit</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">coordSys</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'ricci'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measureBeltramiCoefficient</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="c">%% Strain rate (epsilon = 1/2 (djvi+divj) -vn bij)</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measureStrainRate</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Plot time-averaged strain rates in 3d on mesh</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotStrainRate3DFiltered</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Kymograph strain rates</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">clim_trace</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">clim_deviatoric</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotStrainRate</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">% Measure strain rate along pathlines</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwriteImages</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">plot_dzdp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePathlineStrainRate</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Measure divergence and out-of-plane deformation along pathlines</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePathlineMetricKinematics</span><span class="p">()</span><span class="w"></span>

<span class="c">% Pathline strain rate plots</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climit</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climitWide</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotPathlineStrainRate</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>

<span class="c">%% Measure strain along pathlines -- note this is from pathlines, not integrating rates</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">plot_dzdp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climitInitial</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climitRamp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">climitRatio</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">measurePathlineStrain</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">plotPathlineStrain</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"></span>


<span class="c">%% Perform PCA</span><span class="w"></span>
<span class="n">options</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">overwrite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">convert_to_period</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">NmodesToView</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">nTimePoints2RmEnds</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">drawArrowsInPCA3D</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">drawArrowsInPCAPlane</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">meshChoice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">'sphi'</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">pcaTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="s">'v3d'</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">plotArrowsOnModes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">nArrows</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">150</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">tubi</span><span class="p">.</span><span class="n">getPCAoverTime</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<section id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="example_usage_imsane_with_tubular.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Example for using TubULAR methods within ImSAnE</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="example_usage_tubular_for_surface_visualization.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Example for using TubULAR just for surface visualization</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Noah P Mitchell and Dillon J Cislo
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contents
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Example for using TubULAR: zebrafish heart dynamics</a><ul>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    </body>
</html>